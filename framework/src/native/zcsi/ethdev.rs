#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val as u64
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const __USE_ANSI: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _SVID_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_BSD: u32 = 1;
pub const __USE_SVID: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201103;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 17;
pub const __GLIBC_HAVE_LONG_LONG: u32 = 1;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const RTE_EXEC_ENV: &'static [u8; 9usize] = b"linuxapp\0";
pub const RTE_ARCH: &'static [u8; 7usize] = b"x86_64\0";
pub const RTE_MACHINE: &'static [u8; 7usize] = b"native\0";
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\0";
pub const RTE_NEXT_ABI: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_LIBRTE_EAL: u32 = 1;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_NUMA_NODES: u32 = 8;
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 64;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 131072;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_LOG_HISTORY: u32 = 256;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_EAL_IGB_UIO: u32 = 1;
pub const RTE_EAL_VFIO: u32 = 1;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_ENABLE_AVX: u32 = 1;
pub const RTE_EAL_PMD_PATH: &'static [u8; 1usize] = b"\0";
pub const RTE_LIBRTE_EAL_VMWARE_TSC_MAP_SUPPORT: u32 = 1;
pub const RTE_LIBRTE_PCI: u32 = 1;
pub const RTE_LIBRTE_KVARGS: u32 = 1;
pub const RTE_LIBRTE_ETHER: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_LIBRTE_IFPGA_BUS: u32 = 1;
pub const RTE_LIBRTE_PCI_BUS: u32 = 1;
pub const RTE_LIBRTE_VDEV_BUS: u32 = 1;
pub const RTE_LIBRTE_ARK_PMD: u32 = 1;
pub const RTE_LIBRTE_ARK_PAD_TX: u32 = 1;
pub const RTE_LIBRTE_ATLANTIC_PMD: u32 = 1;
pub const RTE_LIBRTE_AXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_BNXT_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_TPUT: u32 = 1;
pub const RTE_LIBRTE_DPAA2_USE_PHYS_IOVA: u32 = 1;
pub const RTE_LIBRTE_ENA_PMD: u32 = 1;
pub const RTE_LIBRTE_ENIC_PMD: u32 = 1;
pub const RTE_LIBRTE_EM_PMD: u32 = 1;
pub const RTE_LIBRTE_IGB_PMD: u32 = 1;
pub const RTE_LIBRTE_IXGBE_PMD: u32 = 1;
pub const RTE_IXGBE_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_PMD: u32 = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_LIBRTE_FM10K_PMD: u32 = 1;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_AVF_PMD: u32 = 1;
pub const RTE_LIBRTE_AVF_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_NFP_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\0";
pub const RTE_LIBRTE_SFC_EFX_PMD: u32 = 1;
pub const RTE_LIBRTE_THUNDERX_NICVF_PMD: u32 = 1;
pub const RTE_LIBRTE_LIO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_PMD: u32 = 1;
pub const RTE_LIBRTE_AVP_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: u32 = 1;
pub const RTE_VIRTIO_USER: u32 = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: u32 = 1;
pub const RTE_LIBRTE_PMD_AF_PACKET: u32 = 1;
pub const RTE_LIBRTE_PMD_BOND: u32 = 1;
pub const RTE_LIBRTE_PMD_FAILSAFE: u32 = 1;
pub const RTE_LIBRTE_VMBUS: u32 = 1;
pub const RTE_LIBRTE_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_VDEV_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_PMD_NULL: u32 = 1;
pub const RTE_LIBRTE_PMD_PCAP: u32 = 1;
pub const RTE_LIBRTE_PMD_RING: u32 = 1;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_PMD_SOFTNIC: u32 = 1;
pub const RTE_LIBRTE_PMD_TAP: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_LIBRTE_BBDEV: u32 = 1;
pub const RTE_BBDEV_MAX_DEVS: u32 = 128;
pub const RTE_LIBRTE_PMD_BBDEV_NULL: u32 = 1;
pub const RTE_LIBRTE_CRYPTODEV: u32 = 1;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_PMD_OCTEONTX_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_PMD_QAT: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_LIBRTE_PMD_VIRTIO_CRYPTO: u32 = 1;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_PMD_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_LIBRTE_PMD_NULL_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_SECURITY: u32 = 1;
pub const RTE_LIBRTE_COMPRESSDEV: u32 = 1;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_PMD_OCTEONTX_ZIPVF: u32 = 1;
pub const RTE_LIBRTE_EVENTDEV: u32 = 1;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 64;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_LIBRTE_PMD_SKELETON_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SW_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DSW_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX_SSOVF: u32 = 1;
pub const RTE_LIBRTE_PMD_OPDL_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_RAWDEV: u32 = 1;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 10;
pub const RTE_LIBRTE_PMD_SKELETON_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_IFPGA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_RING: u32 = 1;
pub const RTE_LIBRTE_MEMPOOL: u32 = 1;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_DRIVER_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_DRIVER_MEMPOOL_RING: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_STACK: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_MBUF: u32 = 1;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] = b"ring_mp_mc\0";
pub const RTE_MBUF_REFCNT_ATOMIC: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_LIBRTE_TIMER: u32 = 1;
pub const RTE_LIBRTE_CFGFILE: u32 = 1;
pub const RTE_LIBRTE_CMDLINE: u32 = 1;
pub const RTE_LIBRTE_HASH: u32 = 1;
pub const RTE_LIBRTE_EFD: u32 = 1;
pub const RTE_LIBRTE_MEMBER: u32 = 1;
pub const RTE_LIBRTE_JOBSTATS: u32 = 1;
pub const RTE_LIBRTE_METRICS: u32 = 1;
pub const RTE_LIBRTE_BITRATE: u32 = 1;
pub const RTE_LIBRTE_LATENCY_STATS: u32 = 1;
pub const RTE_LIBRTE_LPM: u32 = 1;
pub const RTE_LIBRTE_ACL: u32 = 1;
pub const RTE_LIBRTE_POWER: u32 = 1;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_LIBRTE_NET: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 4;
pub const RTE_LIBRTE_GRO: u32 = 1;
pub const RTE_LIBRTE_GSO: u32 = 1;
pub const RTE_LIBRTE_METER: u32 = 1;
pub const RTE_LIBRTE_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIBRTE_SCHED: u32 = 1;
pub const RTE_SCHED_PORT_N_GRINDERS: u32 = 8;
pub const RTE_LIBRTE_DISTRIBUTOR: u32 = 1;
pub const RTE_LIBRTE_REORDER: u32 = 1;
pub const RTE_LIBRTE_PORT: u32 = 1;
pub const RTE_PORT_PCAP: u32 = 1;
pub const RTE_LIBRTE_TABLE: u32 = 1;
pub const RTE_LIBRTE_PIPELINE: u32 = 1;
pub const RTE_LIBRTE_KNI: u32 = 1;
pub const RTE_LIBRTE_PMD_KNI: u32 = 1;
pub const RTE_KNI_KMOD: u32 = 1;
pub const RTE_KNI_PREEMPT_DEFAULT: u32 = 1;
pub const RTE_LIBRTE_PDUMP: u32 = 1;
pub const RTE_LIBRTE_VHOST: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIBRTE_PMD_VHOST: u32 = 1;
pub const RTE_LIBRTE_IFC_PMD: u32 = 1;
pub const RTE_LIBRTE_BPF: u32 = 1;
pub const RTE_APP_TEST: u32 = 1;
pub const RTE_PROC_INFO: u32 = 1;
pub const RTE_TEST_PMD: u32 = 1;
pub const RTE_TEST_BBDEV: u32 = 1;
pub const RTE_APP_CRYPTO_PERF: u32 = 1;
pub const RTE_APP_EVENTDEV: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_PCI_CONFIG: u32 = 1;
pub const RTE_PCI_EXTENDED_TAG: &'static [u8; 3usize] = b"on\0";
pub const RTE_PCI_MAX_READ_REQUEST_SIZE: u32 = 128;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_64: u32 = 1;
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_ELISION: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_MAX: u32 = 23;
pub const ETHER_ADDR_LEN: u32 = 6;
pub const RTE_ETHTYPE_FLAGS_MAC: u32 = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: u32 = 2;
pub const RTE_FLEX_FILTER_MAXLEN: u32 = 128;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const TCP_URG_FLAG: u32 = 32;
pub const TCP_ACK_FLAG: u32 = 16;
pub const TCP_PSH_FLAG: u32 = 8;
pub const TCP_RST_FLAG: u32 = 4;
pub const TCP_SYN_FLAG: u32 = 2;
pub const TCP_FIN_FLAG: u32 = 1;
pub const TCP_FLAG_ALL: u32 = 63;
pub const ETH_TUNNEL_FILTER_OMAC: u32 = 1;
pub const ETH_TUNNEL_FILTER_OIP: u32 = 2;
pub const ETH_TUNNEL_FILTER_TENID: u32 = 4;
pub const ETH_TUNNEL_FILTER_IMAC: u32 = 8;
pub const ETH_TUNNEL_FILTER_IVLAN: u32 = 16;
pub const ETH_TUNNEL_FILTER_IIP: u32 = 32;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN: u32 = 24;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID: u32 = 28;
pub const RTE_TUNNEL_FILTER_IMAC_TENID: u32 = 12;
pub const RTE_TUNNEL_FILTER_OMAC_TENID_IMAC: u32 = 13;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const ETH_LINK_SPEED_FIXED: u32 = 1;
pub const ETH_LINK_SPEED_10M_HD: u32 = 2;
pub const ETH_LINK_SPEED_10M: u32 = 4;
pub const ETH_LINK_SPEED_100M_HD: u32 = 8;
pub const ETH_LINK_SPEED_100M: u32 = 16;
pub const ETH_LINK_SPEED_1G: u32 = 32;
pub const ETH_LINK_SPEED_2_5G: u32 = 64;
pub const ETH_LINK_SPEED_5G: u32 = 128;
pub const ETH_LINK_SPEED_10G: u32 = 256;
pub const ETH_LINK_SPEED_20G: u32 = 512;
pub const ETH_LINK_SPEED_25G: u32 = 1024;
pub const ETH_LINK_SPEED_40G: u32 = 2048;
pub const ETH_LINK_SPEED_50G: u32 = 4096;
pub const ETH_LINK_SPEED_56G: u32 = 8192;
pub const ETH_LINK_SPEED_100G: u32 = 16384;
pub const ETH_SPEED_NUM_NONE: u32 = 0;
pub const ETH_SPEED_NUM_10M: u32 = 10;
pub const ETH_SPEED_NUM_100M: u32 = 100;
pub const ETH_SPEED_NUM_1G: u32 = 1000;
pub const ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const ETH_SPEED_NUM_5G: u32 = 5000;
pub const ETH_SPEED_NUM_10G: u32 = 10000;
pub const ETH_SPEED_NUM_20G: u32 = 20000;
pub const ETH_SPEED_NUM_25G: u32 = 25000;
pub const ETH_SPEED_NUM_40G: u32 = 40000;
pub const ETH_SPEED_NUM_50G: u32 = 50000;
pub const ETH_SPEED_NUM_56G: u32 = 56000;
pub const ETH_SPEED_NUM_100G: u32 = 100000;
pub const ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const ETH_LINK_DOWN: u32 = 0;
pub const ETH_LINK_UP: u32 = 1;
pub const ETH_LINK_FIXED: u32 = 0;
pub const ETH_LINK_AUTONEG: u32 = 1;
pub const ETH_MQ_RX_RSS_FLAG: u32 = 1;
pub const ETH_MQ_RX_DCB_FLAG: u32 = 2;
pub const ETH_MQ_RX_VMDQ_FLAG: u32 = 4;
pub const ETH_RSS_IPV4: u32 = 4;
pub const ETH_RSS_FRAG_IPV4: u32 = 8;
pub const ETH_RSS_NONFRAG_IPV4_TCP: u32 = 16;
pub const ETH_RSS_NONFRAG_IPV4_UDP: u32 = 32;
pub const ETH_RSS_NONFRAG_IPV4_SCTP: u32 = 64;
pub const ETH_RSS_NONFRAG_IPV4_OTHER: u32 = 128;
pub const ETH_RSS_IPV6: u32 = 256;
pub const ETH_RSS_FRAG_IPV6: u32 = 512;
pub const ETH_RSS_NONFRAG_IPV6_TCP: u32 = 1024;
pub const ETH_RSS_NONFRAG_IPV6_UDP: u32 = 2048;
pub const ETH_RSS_NONFRAG_IPV6_SCTP: u32 = 4096;
pub const ETH_RSS_NONFRAG_IPV6_OTHER: u32 = 8192;
pub const ETH_RSS_L2_PAYLOAD: u32 = 16384;
pub const ETH_RSS_IPV6_EX: u32 = 32768;
pub const ETH_RSS_IPV6_TCP_EX: u32 = 65536;
pub const ETH_RSS_IPV6_UDP_EX: u32 = 131072;
pub const ETH_RSS_PORT: u32 = 262144;
pub const ETH_RSS_VXLAN: u32 = 524288;
pub const ETH_RSS_GENEVE: u32 = 1048576;
pub const ETH_RSS_NVGRE: u32 = 2097152;
pub const ETH_RSS_IP: u32 = 41868;
pub const ETH_RSS_UDP: u32 = 133152;
pub const ETH_RSS_TCP: u32 = 66576;
pub const ETH_RSS_SCTP: u32 = 4160;
pub const ETH_RSS_TUNNEL: u32 = 3670016;
pub const ETH_RSS_PROTO_MASK: u32 = 4194300;
pub const ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_RETA_GROUP_SIZE: u32 = 64;
pub const ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_PG_SUPPORT: u32 = 1;
pub const ETH_DCB_PFC_SUPPORT: u32 = 2;
pub const ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const ETH_VLAN_STRIP_MASK: u32 = 1;
pub const ETH_VLAN_FILTER_MASK: u32 = 2;
pub const ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const ETH_VLAN_ID_MAX: u32 = 4095;
pub const ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const ETH_VMDQ_ACCEPT_UNTAG: u32 = 1;
pub const ETH_VMDQ_ACCEPT_HASH_MC: u32 = 2;
pub const ETH_VMDQ_ACCEPT_HASH_UC: u32 = 4;
pub const ETH_VMDQ_ACCEPT_BROADCAST: u32 = 8;
pub const ETH_VMDQ_ACCEPT_MULTICAST: u32 = 16;
pub const ETH_MIRROR_MAX_VLANS: u32 = 64;
pub const ETH_MIRROR_VIRTUAL_POOL_UP: u32 = 1;
pub const ETH_MIRROR_UPLINK_PORT: u32 = 2;
pub const ETH_MIRROR_DOWNLINK_PORT: u32 = 4;
pub const ETH_MIRROR_VLAN: u32 = 8;
pub const ETH_MIRROR_VIRTUAL_POOL_DOWN: u32 = 16;
pub const DEV_RX_OFFLOAD_VLAN_STRIP: u32 = 1;
pub const DEV_RX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_RX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_RX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_RX_OFFLOAD_TCP_LRO: u32 = 16;
pub const DEV_RX_OFFLOAD_QINQ_STRIP: u32 = 32;
pub const DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 64;
pub const DEV_RX_OFFLOAD_MACSEC_STRIP: u32 = 128;
pub const DEV_RX_OFFLOAD_HEADER_SPLIT: u32 = 256;
pub const DEV_RX_OFFLOAD_VLAN_FILTER: u32 = 512;
pub const DEV_RX_OFFLOAD_VLAN_EXTEND: u32 = 1024;
pub const DEV_RX_OFFLOAD_JUMBO_FRAME: u32 = 2048;
pub const DEV_RX_OFFLOAD_SCATTER: u32 = 8192;
pub const DEV_RX_OFFLOAD_TIMESTAMP: u32 = 16384;
pub const DEV_RX_OFFLOAD_SECURITY: u32 = 32768;
pub const DEV_RX_OFFLOAD_KEEP_CRC: u32 = 65536;
pub const DEV_RX_OFFLOAD_SCTP_CKSUM: u32 = 131072;
pub const DEV_RX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 262144;
pub const DEV_RX_OFFLOAD_CHECKSUM: u32 = 14;
pub const DEV_RX_OFFLOAD_VLAN: u32 = 1537;
pub const DEV_TX_OFFLOAD_VLAN_INSERT: u32 = 1;
pub const DEV_TX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_TX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_TX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_TX_OFFLOAD_SCTP_CKSUM: u32 = 16;
pub const DEV_TX_OFFLOAD_TCP_TSO: u32 = 32;
pub const DEV_TX_OFFLOAD_UDP_TSO: u32 = 64;
pub const DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 128;
pub const DEV_TX_OFFLOAD_QINQ_INSERT: u32 = 256;
pub const DEV_TX_OFFLOAD_VXLAN_TNL_TSO: u32 = 512;
pub const DEV_TX_OFFLOAD_GRE_TNL_TSO: u32 = 1024;
pub const DEV_TX_OFFLOAD_IPIP_TNL_TSO: u32 = 2048;
pub const DEV_TX_OFFLOAD_GENEVE_TNL_TSO: u32 = 4096;
pub const DEV_TX_OFFLOAD_MACSEC_INSERT: u32 = 8192;
pub const DEV_TX_OFFLOAD_MT_LOCKFREE: u32 = 16384;
pub const DEV_TX_OFFLOAD_MULTI_SEGS: u32 = 32768;
pub const DEV_TX_OFFLOAD_MBUF_FAST_FREE: u32 = 65536;
pub const DEV_TX_OFFLOAD_SECURITY: u32 = 131072;
pub const DEV_TX_OFFLOAD_UDP_TNL_TSO: u32 = 262144;
pub const DEV_TX_OFFLOAD_IP_TNL_TSO: u32 = 524288;
pub const DEV_TX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 1048576;
pub const DEV_TX_OFFLOAD_MATCH_METADATA: u32 = 2097152;
pub const RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP: u32 = 1;
pub const RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP: u32 = 2;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 0;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const ETH_DCB_NUM_TCS: u32 = 8;
pub const ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_QUEUE_STATE_STOPPED: u32 = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: u32 = 1;
pub const RTE_ETH_ALL: u32 = 32;
pub const ETH_L2_TUNNEL_ENABLE_MASK: u32 = 1;
pub const ETH_L2_TUNNEL_INSERTION_MASK: u32 = 2;
pub const ETH_L2_TUNNEL_STRIPPING_MASK: u32 = 4;
pub const ETH_L2_TUNNEL_FORWARDING_MASK: u32 = 8;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_DEV_CLOSE_REMOVE: u32 = 1;
pub const RTE_ETH_DEV_INTR_LSC: u32 = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: u32 = 4;
pub const RTE_ETH_DEV_INTR_RMV: u32 = 8;
pub const RTE_ETH_DEV_REPRESENTOR: u32 = 16;
pub const RTE_ETH_DEV_NOLIVE_MAC_ADDR: u32 = 32;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_termsig: ::std::os::raw::c_uint,
        __w_coredump: ::std::os::raw::c_uint,
        __w_retcode: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __w_termsig: u32 = unsafe { ::std::mem::transmute(__w_termsig) };
            __w_termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __w_coredump: u32 = unsafe { ::std::mem::transmute(__w_coredump) };
            __w_coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_retcode: u32 = unsafe { ::std::mem::transmute(__w_retcode) };
            __w_retcode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_stopval: ::std::os::raw::c_uint,
        __w_stopsig: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let __w_stopval: u32 = unsafe { ::std::mem::transmute(__w_stopval) };
            __w_stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_stopsig: u32 = unsafe { ::std::mem::transmute(__w_stopsig) };
            __w_stopsig as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).__wait_terminated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).__wait_stopped as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(__wait_stopped))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Size of: ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__uptr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__WAIT_STATUS), "::", stringify!(__uptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__iptr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__WAIT_STATUS), "::", stringify!(__iptr))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(div_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(div_t), "::", stringify!(rem))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(rem))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(rem))
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__sigset_t), "::", stringify!(__val))
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_sec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_nsec))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_sec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_usec))
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(fd_set), "::", stringify!(__fds_bits))
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_ulong,
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__readers_wakeup as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers_wakeup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer_wakeup as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer_wakeup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers_queued as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers_queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_writers_queued as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_writers_queued)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__shared as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(fptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(rptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(rand_deg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(rand_sep))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(end_ptr))
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char, __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__old_x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__a))
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: ::std::os::raw::c_ulong, __size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(__func: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong, __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = u32;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
extern "C" {
    #[doc = " Function to terminate the application immediately, printing an error"]
    #[doc = " message and returning the exit_code back to the shell."]
    #[doc = ""]
    #[doc = " This function never returns"]
    #[doc = ""]
    #[doc = " @param exit_code"]
    #[doc = "     The exit code to be returned by the application"]
    #[doc = " @param format"]
    #[doc = "     The format string to be used for printing the message. This can include"]
    #[doc = "     printf format characters which will be expanded using any further parameters"]
    #[doc = "     to the function."]
    pub fn rte_exit(exit_code: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
pub const rte_filter_type_RTE_ETH_FILTER_NONE: rte_filter_type = 0;
pub const rte_filter_type_RTE_ETH_FILTER_MACVLAN: rte_filter_type = 1;
pub const rte_filter_type_RTE_ETH_FILTER_ETHERTYPE: rte_filter_type = 2;
pub const rte_filter_type_RTE_ETH_FILTER_FLEXIBLE: rte_filter_type = 3;
pub const rte_filter_type_RTE_ETH_FILTER_SYN: rte_filter_type = 4;
pub const rte_filter_type_RTE_ETH_FILTER_NTUPLE: rte_filter_type = 5;
pub const rte_filter_type_RTE_ETH_FILTER_TUNNEL: rte_filter_type = 6;
pub const rte_filter_type_RTE_ETH_FILTER_FDIR: rte_filter_type = 7;
pub const rte_filter_type_RTE_ETH_FILTER_HASH: rte_filter_type = 8;
pub const rte_filter_type_RTE_ETH_FILTER_L2_TUNNEL: rte_filter_type = 9;
pub const rte_filter_type_RTE_ETH_FILTER_GENERIC: rte_filter_type = 10;
pub const rte_filter_type_RTE_ETH_FILTER_MAX: rte_filter_type = 11;
#[doc = " Feature filter types"]
pub type rte_filter_type = u32;
#[doc = " used to check whether the type filter is supported"]
pub const rte_filter_op_RTE_ETH_FILTER_NOP: rte_filter_op = 0;
#[doc = "< add filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_ADD: rte_filter_op = 1;
#[doc = "< update filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_UPDATE: rte_filter_op = 2;
#[doc = "< delete filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_DELETE: rte_filter_op = 3;
#[doc = "< flush all entries"]
pub const rte_filter_op_RTE_ETH_FILTER_FLUSH: rte_filter_op = 4;
#[doc = "< get filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_GET: rte_filter_op = 5;
#[doc = "< configurations"]
pub const rte_filter_op_RTE_ETH_FILTER_SET: rte_filter_op = 6;
#[doc = "< retrieve information"]
pub const rte_filter_op_RTE_ETH_FILTER_INFO: rte_filter_op = 7;
#[doc = "< retrieve statistics"]
pub const rte_filter_op_RTE_ETH_FILTER_STATS: rte_filter_op = 8;
pub const rte_filter_op_RTE_ETH_FILTER_OP_MAX: rte_filter_op = 9;
#[doc = " Generic operations on filters"]
pub type rte_filter_op = u32;
#[doc = "< exact match of MAC addr."]
pub const rte_mac_filter_type_RTE_MAC_PERFECT_MATCH: rte_mac_filter_type = 1;
#[doc = "< exact match of MAC addr and VLAN ID."]
pub const rte_mac_filter_type_RTE_MACVLAN_PERFECT_MATCH: rte_mac_filter_type = 2;
#[doc = "< hash match of MAC addr."]
pub const rte_mac_filter_type_RTE_MAC_HASH_MATCH: rte_mac_filter_type = 3;
#[doc = " hash match of MAC addr and exact match of VLAN ID."]
pub const rte_mac_filter_type_RTE_MACVLAN_HASH_MATCH: rte_mac_filter_type = 4;
#[doc = " MAC filter type"]
pub type rte_mac_filter_type = u32;
#[doc = " Ethernet address:"]
#[doc = " A universally administered address is uniquely assigned to a device by its"]
#[doc = " manufacturer. The first three octets (in transmission order) contain the"]
#[doc = " Organizationally Unique Identifier (OUI). The following three (MAC-48 and"]
#[doc = " EUI-48) octets are assigned by that organization with the only constraint"]
#[doc = " of uniqueness."]
#[doc = " A locally administered address is assigned to a device by a network"]
#[doc = " administrator and does not contain OUIs."]
#[doc = " See http://standards.ieee.org/regauth/groupmac/tutorial.html"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ether_addr {
    #[doc = "< Addr bytes in tx order"]
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(
        ::std::mem::size_of::<ether_addr>(),
        6usize,
        concat!("Size of: ", stringify!(ether_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(ether_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_addr>())).addr_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_addr),
            "::",
            stringify!(addr_bytes)
        )
    );
}
#[doc = " MAC filter info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_mac_filter {
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
    #[doc = "< MAC filter type"]
    pub filter_type: rte_mac_filter_type,
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_filter>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).is_vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).dst_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(dst_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).filter_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " A structure used to define the ethertype filter entry"]
#[doc = " to support RTE_ETH_FILTER_ETHERTYPE with RTE_ETH_FILTER_ADD,"]
#[doc = " RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ethertype_filter {
    #[doc = "< Mac address to match."]
    pub mac_addr: ether_addr,
    #[doc = "< Ether type to match"]
    pub ether_type: u16,
    #[doc = "< Flags from RTE_ETHTYPE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ethertype_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ethertype_filter>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ethertype_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).ether_type as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).queue as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = "  A structure used to define the flex filter entry"]
#[doc = "  to support RTE_ETH_FILTER_FLEXIBLE with RTE_ETH_FILTER_ADD,"]
#[doc = "  RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_flex_filter {
    pub len: u16,
    #[doc = "< flex bytes in big endian."]
    pub bytes: [u8; 128usize],
    #[doc = "< if mask bit is 1b, do"]
    #[doc = "not compare corresponding byte."]
    pub mask: [u8; 16usize],
    pub priority: u8,
    #[doc = "< Queue assigned to when match."]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_flex_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_filter>(),
        150usize,
        concat!("Size of: ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).mask as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).priority as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).queue as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = " A structure used to define the TCP syn filter entry"]
#[doc = " to support RTE_ETH_FILTER_SYN with RTE_ETH_FILTER_ADD,"]
#[doc = " RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_syn_filter {
    #[doc = "< 1 - higher priority than other filters,"]
    #[doc = "0 - lower priority."]
    pub hig_pri: u8,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_syn_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_syn_filter>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_syn_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).hig_pri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(hig_pri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = " A structure used to define the ntuple filter entry"]
#[doc = " to support RTE_ETH_FILTER_NTUPLE with RTE_ETH_FILTER_ADD,"]
#[doc = " RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ntuple_filter {
    #[doc = "< Flags from RTE_NTUPLE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Destination IP address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub dst_ip_mask: u32,
    #[doc = "< Source IP address in big endian."]
    pub src_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub src_ip_mask: u32,
    #[doc = "< Destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Mask of destination port."]
    pub dst_port_mask: u16,
    #[doc = "< Source Port in big endian."]
    pub src_port: u16,
    #[doc = "< Mask of source port."]
    pub src_port_mask: u16,
    #[doc = "< L4 protocol."]
    pub proto: u8,
    #[doc = "< Mask of L4 protocol."]
    pub proto_mask: u8,
    #[doc = " tcp_flags only meaningful when the proto is TCP."]
    #[doc = "The packet matched above ntuple fields and contain"]
    #[doc = "any set bit in tcp_flags will hit this filter."]
    pub tcp_flags: u8,
    #[doc = "< seven levels (001b-111b), 111b is highest,"]
    #[doc = "used when more than one filter matches."]
    pub priority: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ntuple_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ntuple_filter>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ntuple_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port_mask as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port_mask as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto_mask as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).tcp_flags as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).priority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).queue as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(queue)
        )
    );
}
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_NONE: rte_eth_tunnel_type = 0;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_VXLAN: rte_eth_tunnel_type = 1;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_GENEVE: rte_eth_tunnel_type = 2;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_TEREDO: rte_eth_tunnel_type = 3;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_NVGRE: rte_eth_tunnel_type = 4;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_IP_IN_GRE: rte_eth_tunnel_type = 5;
pub const rte_eth_tunnel_type_RTE_L2_TUNNEL_TYPE_E_TAG: rte_eth_tunnel_type = 6;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_MAX: rte_eth_tunnel_type = 7;
#[doc = " Tunneled type."]
pub type rte_eth_tunnel_type = u32;
#[doc = "< IPv4."]
pub const rte_tunnel_iptype_RTE_TUNNEL_IPTYPE_IPV4: rte_tunnel_iptype = 0;
#[doc = "< IPv6."]
pub const rte_tunnel_iptype_RTE_TUNNEL_IPTYPE_IPV6: rte_tunnel_iptype = 1;
#[doc = "  Select IPv4 or IPv6 for tunnel filters."]
pub type rte_tunnel_iptype = u32;
#[doc = " Tunneling Packet filter configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tunnel_filter_conf {
    #[doc = "< Outer MAC address to match."]
    pub outer_mac: ether_addr,
    #[doc = "< Inner MAC address to match."]
    pub inner_mac: ether_addr,
    #[doc = "< Inner VLAN to match."]
    pub inner_vlan: u16,
    #[doc = "< IP address type."]
    pub ip_type: rte_tunnel_iptype,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    #[doc = " Flags from ETH_TUNNEL_FILTER_XX - see above."]
    pub filter_type: u16,
    #[doc = "< Tunnel Type."]
    pub tunnel_type: rte_eth_tunnel_type,
    #[doc = "< Tenant ID to match. VNI, GRE key..."]
    pub tenant_id: u32,
    #[doc = "< Queue assigned to if match."]
    pub queue_id: u16,
}
#[doc = " Outer destination IP address to match if ETH_TUNNEL_FILTER_OIP"]
#[doc = "is set in filter_type, or inner destination IP address to match"]
#[doc = "if ETH_TUNNEL_FILTER_IIP is set in filter_type ."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    #[doc = "< IPv4 address in big endian."]
    pub ipv4_addr: u32,
    #[doc = "< IPv6 address in big endian."]
    pub ipv6_addr: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv4_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv4_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf>(),
        52usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).outer_mac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(outer_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_mac as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_vlan as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_vlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_addr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).filter_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tunnel_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tenant_id as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tenant_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).queue_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(queue_id)
        )
    );
}
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_UNKNOWN: rte_eth_global_cfg_type = 0;
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN: rte_eth_global_cfg_type = 1;
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_MAX: rte_eth_global_cfg_type = 2;
#[doc = " Global eth device configuration type."]
pub type rte_eth_global_cfg_type = u32;
#[doc = " Global eth device configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_global_cfg {
    #[doc = "< Global config type."]
    pub cfg_type: rte_eth_global_cfg_type,
    pub cfg: rte_eth_global_cfg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_global_cfg__bindgen_ty_1 {
    #[doc = "< Valid GRE key length in byte."]
    pub gre_key_len: u8,
    #[doc = "< Reserve space for future use."]
    pub reserved: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_global_cfg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).gre_key_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(gre_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg)
        )
    );
}
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_UNKNOWN: rte_eth_input_set_field = 0;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_SRC_MAC: rte_eth_input_set_field = 1;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_DST_MAC: rte_eth_input_set_field = 2;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_OUTER_VLAN: rte_eth_input_set_field = 3;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_INNER_VLAN: rte_eth_input_set_field = 4;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_ETHERTYPE: rte_eth_input_set_field = 5;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP4: rte_eth_input_set_field = 129;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP4: rte_eth_input_set_field = 130;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP6: rte_eth_input_set_field = 131;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP6: rte_eth_input_set_field = 132;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TOS: rte_eth_input_set_field = 133;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_PROTO: rte_eth_input_set_field = 134;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_TC: rte_eth_input_set_field = 135;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER: rte_eth_input_set_field = 136;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TTL: rte_eth_input_set_field = 137;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS: rte_eth_input_set_field = 138;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT: rte_eth_input_set_field = 257;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_DST_PORT: rte_eth_input_set_field = 258;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT: rte_eth_input_set_field = 259;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_DST_PORT: rte_eth_input_set_field = 260;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT: rte_eth_input_set_field = 261;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT: rte_eth_input_set_field = 262;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG: rte_eth_input_set_field = 263;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC: rte_eth_input_set_field = 385;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC: rte_eth_input_set_field = 386;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN: rte_eth_input_set_field = 387;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY: rte_eth_input_set_field = 388;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY: rte_eth_input_set_field = 389;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD: rte_eth_input_set_field = 641;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD: rte_eth_input_set_field = 642;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD: rte_eth_input_set_field = 643;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD: rte_eth_input_set_field = 644;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD: rte_eth_input_set_field = 645;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD: rte_eth_input_set_field = 646;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD: rte_eth_input_set_field = 647;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD: rte_eth_input_set_field = 648;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_DEFAULT: rte_eth_input_set_field = 65533;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_NONE: rte_eth_input_set_field = 65534;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_MAX: rte_eth_input_set_field = 65535;
#[doc = " Input set fields for Flow Director and Hash filters"]
pub type rte_eth_input_set_field = u32;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_UNKNOWN: rte_filter_input_set_op = 0;
#[doc = "< select input set"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_SELECT: rte_filter_input_set_op = 1;
#[doc = "< add input set entry"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_ADD: rte_filter_input_set_op = 2;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_MAX: rte_filter_input_set_op = 3;
#[doc = " Filters input set operations"]
pub type rte_filter_input_set_op = u32;
#[doc = " A structure used to define the input set configuration for"]
#[doc = " flow director and hash filters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field; 128usize],
    pub op: rte_filter_input_set_op,
}
#[test]
fn bindgen_test_layout_rte_eth_input_set_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_input_set_conf>(),
        520usize,
        concat!("Size of: ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_input_set_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).inset_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(inset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).field as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).op as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(op)
        )
    );
}
#[doc = " A structure used to define the input for L2 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_l2_flow {
    #[doc = "< Ether type in big endian"]
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Size of: ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_flow>())).ether_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_flow),
            "::",
            stringify!(ether_type)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv4_flow {
    #[doc = "< IPv4 source address in big endian."]
    pub src_ip: u32,
    #[doc = "< IPv4 destination address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Type of service to match."]
    pub tos: u8,
    #[doc = "< Time to live to match."]
    pub ttl: u8,
    #[doc = "< Protocol, next header in big endian."]
    pub proto: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv4_flow>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).tos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).ttl as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).proto as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(proto)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< TCP source port in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian"]
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv4_flow>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).verify_tag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv6_flow {
    #[doc = "< IPv6 source address in big endian."]
    pub src_ip: [u32; 4usize],
    #[doc = "< IPv6 destination address in big endian."]
    pub dst_ip: [u32; 4usize],
    #[doc = "< Traffic class to match."]
    pub tc: u8,
    #[doc = "< Protocol, next header to match."]
    pub proto: u8,
    #[doc = "< Hop limits to match."]
    pub hop_limits: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv6_flow>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).tc as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_eth_ipv6_flow), "::", stringify!(tc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).proto as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).hop_limits as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(hop_limits)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< TCP source port to in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian."]
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv6_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).verify_tag as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[doc = " A structure used to define the input for MAC VLAN flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_mac_vlan_flow {
    #[doc = "< Mac address to match."]
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_vlan_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_vlan_flow>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_vlan_flow>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_vlan_flow>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_vlan_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_UNKNOWN: rte_eth_fdir_tunnel_type = 0;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_NVGRE: rte_eth_fdir_tunnel_type = 1;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_VXLAN: rte_eth_fdir_tunnel_type = 2;
#[doc = " Tunnel type for flow director."]
pub type rte_eth_fdir_tunnel_type = u32;
#[doc = " A structure used to define the input for tunnel flow, now it\'s VxLAN or"]
#[doc = " NVGRE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tunnel_flow {
    #[doc = "< Tunnel type to match."]
    pub tunnel_type: rte_eth_fdir_tunnel_type,
    #[doc = " Tunnel ID to match. TNI, VNI... in big endian."]
    pub tunnel_id: u32,
    #[doc = "< Mac address to match."]
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " An union contains the inputs for all types of flow"]
#[doc = " Items in flows need to be in big endian"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_flow {
    pub l2_flow: rte_eth_l2_flow,
    pub udp4_flow: rte_eth_udpv4_flow,
    pub tcp4_flow: rte_eth_tcpv4_flow,
    pub sctp4_flow: rte_eth_sctpv4_flow,
    pub ip4_flow: rte_eth_ipv4_flow,
    pub udp6_flow: rte_eth_udpv6_flow,
    pub tcp6_flow: rte_eth_tcpv6_flow,
    pub sctp6_flow: rte_eth_sctpv6_flow,
    pub ipv6_flow: rte_eth_ipv6_flow,
    pub mac_vlan_flow: rte_eth_mac_vlan_flow,
    pub tunnel_flow: rte_eth_tunnel_flow,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).l2_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(l2_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ip4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ip4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ipv6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ipv6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).mac_vlan_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(mac_vlan_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tunnel_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tunnel_flow)
        )
    );
}
#[doc = " A structure used to contain extend input of flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow_ext>(),
        22usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow_ext>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).flexbytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(flexbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).is_vf as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).dst_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(dst_id)
        )
    );
}
#[doc = " A structure used to define the input for a flow director filter entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_input() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_input>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_input>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_ext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_ext)
        )
    );
}
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_ACCEPT: rte_eth_fdir_behavior = 0;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_REJECT: rte_eth_fdir_behavior = 1;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_PASSTHRU: rte_eth_fdir_behavior = 2;
#[doc = " Behavior will be taken if FDIR match"]
pub type rte_eth_fdir_behavior = u32;
#[doc = "< Report nothing."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_NO_REPORT_STATUS: rte_eth_fdir_status = 0;
#[doc = "< Only report FD ID."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID: rte_eth_fdir_status = 1;
#[doc = "< Report FD ID and 4 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID_FLEX_4: rte_eth_fdir_status = 2;
#[doc = "< Report 8 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_FLEX_8: rte_eth_fdir_status = 3;
#[doc = " Flow director report status"]
#[doc = " It defines what will be reported if FDIR entry is matched."]
pub type rte_eth_fdir_status = u32;
#[doc = " A structure used to define an action when match FDIR packet filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_action {
    #[doc = "< Queue assigned to if FDIR match."]
    pub rx_queue: u16,
    #[doc = "< Behavior will be taken"]
    pub behavior: rte_eth_fdir_behavior,
    #[doc = "< Status report option"]
    pub report_status: rte_eth_fdir_status,
    pub flex_off: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_action() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_action>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_action>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).rx_queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(rx_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).behavior as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).report_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(report_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).flex_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(flex_off)
        )
    );
}
#[doc = " A structure used to define the flow director filter entry by filter_ctrl API"]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_ADD and"]
#[doc = " RTE_ETH_FILTER_DELETE operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    #[doc = "< Input set"]
    pub input: rte_eth_fdir_input,
    #[doc = "< Action taken when match"]
    pub action: rte_eth_fdir_action,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter>(),
        92usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).soft_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(soft_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).input as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).action as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(action)
        )
    );
}
#[doc = "  A structure used to configure FDIR masks that are used by the device"]
#[doc = "  to match the various fields of RX packet headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_masks {
    #[doc = "< Bit mask for vlan_tci in big endian"]
    pub vlan_tci_mask: u16,
    #[doc = " Bit mask for ipv4 flow in big endian."]
    pub ipv4_mask: rte_eth_ipv4_flow,
    #[doc = " Bit maks for ipv6 flow in big endian."]
    pub ipv6_mask: rte_eth_ipv6_flow,
    #[doc = " Bit mask for L4 source port in big endian."]
    pub src_port_mask: u16,
    #[doc = " Bit mask for L4 destination port in big endian."]
    pub dst_port_mask: u16,
    #[doc = " 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the"]
    #[doc = "first byte on the wire"]
    pub mac_addr_byte_mask: u8,
    #[doc = " Bit mask for tunnel ID in big endian."]
    pub tunnel_id_mask: u32,
    #[doc = "< 1 - Match tunnel type,"]
    #[doc = "0 - Ignore tunnel type."]
    pub tunnel_type_mask: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_masks() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_masks>(),
        68usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_masks>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).vlan_tci_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(vlan_tci_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv4_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv4_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv6_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv6_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).src_port_mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).dst_port_mask as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).mac_addr_byte_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(mac_addr_byte_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_id_mask as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_id_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_type_mask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_type_mask)
        )
    );
}
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_UNKNOWN: rte_eth_payload_type = 0;
pub const rte_eth_payload_type_RTE_ETH_RAW_PAYLOAD: rte_eth_payload_type = 1;
pub const rte_eth_payload_type_RTE_ETH_L2_PAYLOAD: rte_eth_payload_type = 2;
pub const rte_eth_payload_type_RTE_ETH_L3_PAYLOAD: rte_eth_payload_type = 3;
pub const rte_eth_payload_type_RTE_ETH_L4_PAYLOAD: rte_eth_payload_type = 4;
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_MAX: rte_eth_payload_type = 8;
#[doc = " Payload type"]
pub type rte_eth_payload_type = u32;
#[doc = " A structure used to select bytes extracted from the protocol layers to"]
#[doc = " flexible payload for filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_flex_payload_cfg {
    #[doc = "< Payload type"]
    pub type_: rte_eth_payload_type,
    pub src_offset: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_flex_payload_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_payload_cfg>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_payload_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).src_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(src_offset)
        )
    );
}
#[doc = " A structure used to define FDIR masks for flexible payload"]
#[doc = " for each flow type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_mask() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_mask>(),
        18usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_mask>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).mask as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(mask)
        )
    );
}
#[doc = " A structure used to define all flexible payload related setting"]
#[doc = " include flex payload and flex mask"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_conf {
    #[doc = "< The number of following payload cfg"]
    pub nb_payloads: u16,
    #[doc = "< The number of following mask"]
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 23usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_conf>(),
        708usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_payloads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_payloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_flexmasks as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_flexmasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_set as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_mask as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_mask)
        )
    );
}
#[doc = "< Disable FDIR support."]
pub const rte_fdir_mode_RTE_FDIR_MODE_NONE: rte_fdir_mode = 0;
#[doc = "< Enable FDIR signature filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_SIGNATURE: rte_fdir_mode = 1;
#[doc = "< Enable FDIR perfect filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT: rte_fdir_mode = 2;
#[doc = "< Enable FDIR filter mode - MAC VLAN."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_MAC_VLAN: rte_fdir_mode = 3;
#[doc = "< Enable FDIR filter mode - tunnel."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_TUNNEL: rte_fdir_mode = 4;
#[doc = "  Flow Director setting modes: none, signature or perfect."]
pub type rte_fdir_mode = u32;
#[doc = " A structure used to get the information of flow director filter."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation."]
#[doc = " It includes the mode, flexible payload configuration information,"]
#[doc = " capabilities and supported flow types, flexible payload characters."]
#[doc = " It can be gotten to help taking specific configurations per device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_info {
    #[doc = "< Flow director mode"]
    pub mode: rte_fdir_mode,
    pub mask: rte_eth_fdir_masks,
    #[doc = " Flex payload configuration information"]
    pub flex_conf: rte_eth_fdir_flex_conf,
    #[doc = "< Guaranteed spaces."]
    pub guarant_spc: u32,
    #[doc = "< Best effort spaces."]
    pub best_spc: u32,
    #[doc = " Bit mask for every supported flow type."]
    pub flow_types_mask: [u64; 1usize],
    #[doc = "< Total flex payload in bytes."]
    pub max_flexpayload: u32,
    #[doc = " Flexible payload unit in bytes. Size and alignments of all flex"]
    #[doc = "payload segments should be multiplies of this value."]
    pub flex_payload_unit: u32,
    #[doc = " Max number of flexible payload continuous segments."]
    #[doc = "Each segment should be a multiple of flex_payload_unit."]
    pub max_flex_payload_segment_num: u32,
    #[doc = " Maximum src_offset in bytes allowed. It indicates that"]
    #[doc = "src_offset[i] in struct rte_eth_flex_payload_cfg should be less"]
    #[doc = "than this value."]
    pub flex_payload_limit: u16,
    #[doc = " Flex bitmask unit in bytes. Size of flex bitmasks should be a"]
    #[doc = "multiply of this value."]
    pub flex_bitmask_unit: u32,
    #[doc = " Max supported size of flex bitmasks in flex_bitmask_unit"]
    pub max_flex_bitmask_num: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_info>(),
        824usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_conf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).guarant_spc as *const _ as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(guarant_spc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).best_spc as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(best_spc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flow_types_mask as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flow_types_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flexpayload as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flexpayload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_unit as *const _ as usize },
        804usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_payload_segment_num as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_payload_segment_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_limit as *const _ as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_bitmask_unit as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_bitmask_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_bitmask_num as *const _ as usize },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_bitmask_num)
        )
    );
}
#[doc = " A structure used to define the statistics of flow director."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_stats {
    #[doc = "< Number of filters with collision."]
    pub collision: u32,
    #[doc = "< Number of free filters."]
    pub free: u32,
    pub maxhash: u32,
    #[doc = "< Longest linked list of filters."]
    pub maxlen: u32,
    #[doc = "< Number of added filters."]
    pub add: u64,
    #[doc = "< Number of removed filters."]
    pub remove: u64,
    #[doc = "< Number of failed added filters."]
    pub f_add: u64,
    #[doc = "< Number of failed removed filters."]
    pub f_remove: u64,
    #[doc = "< Number of filters in guaranteed spaces."]
    pub guarant_cnt: u32,
    #[doc = "< Number of filters in best effort spaces."]
    pub best_cnt: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_stats>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).collision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(collision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).free as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxhash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).add as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).remove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_add as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_remove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).guarant_cnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(guarant_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).best_cnt as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(best_cnt)
        )
    );
}
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INFO_TYPE_UNKNOWN: rte_eth_fdir_filter_info_type = 0;
#[doc = " Flow Director filter input set configuration"]
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT: rte_eth_fdir_filter_info_type = 1;
#[doc = " Flow Director filter input set configuration"]
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INFO_TYPE_MAX: rte_eth_fdir_filter_info_type = 2;
#[doc = " Flow Director filter information types."]
pub type rte_eth_fdir_filter_info_type = u32;
#[doc = " A structure used to set FDIR filter information, to support filter type"]
#[doc = " of \'RTE_ETH_FILTER_FDIR\' RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT operation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter_info {
    #[doc = "< Information type"]
    pub info_type: rte_eth_fdir_filter_info_type,
    pub info: rte_eth_fdir_filter_info__bindgen_ty_1,
}
#[doc = " Details of fdir filter information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_filter_info__bindgen_ty_1 {
    #[doc = " Flow Director input set configuration per port"]
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        520usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_filter_info__bindgen_ty_1>())).input_set_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info>(),
        524usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info)
        )
    );
}
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INFO_TYPE_UNKNOWN: rte_eth_hash_filter_info_type = 0;
#[doc = " Symmetric hash enable per port"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT: rte_eth_hash_filter_info_type = 1;
#[doc = " Configure globally for hash filter"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_GLOBAL_CONFIG: rte_eth_hash_filter_info_type = 2;
#[doc = " Global Hash filter input set configuration"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INPUT_SET_SELECT: rte_eth_hash_filter_info_type = 3;
#[doc = " Global Hash filter input set configuration"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INFO_TYPE_MAX: rte_eth_hash_filter_info_type = 4;
#[doc = " Hash filter information types."]
#[doc = " - RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT is for getting/setting the"]
#[doc = "   information/configuration of \'symmetric hash enable\' per port."]
#[doc = " - RTE_ETH_HASH_FILTER_GLOBAL_CONFIG is for getting/setting the global"]
#[doc = "   configurations of hash filters. Those global configurations are valid"]
#[doc = "   for all ports of the same NIC."]
#[doc = " - RTE_ETH_HASH_FILTER_INPUT_SET_SELECT is for setting the global"]
#[doc = "   hash input set fields"]
pub type rte_eth_hash_filter_info_type = u32;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
#[doc = "< Toeplitz"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
#[doc = "< Simple XOR"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 3;
#[doc = " Hash function types."]
pub type rte_eth_hash_function = u32;
#[doc = " A structure used to set or get global hash function configurations which"]
#[doc = " include symmetric hash enable per flow type and hash function type."]
#[doc = " Each bit in sym_hash_enable_mask[] indicates if the symmetric hash of the"]
#[doc = " corresponding flow type is enabled or not."]
#[doc = " Each bit in valid_bit_mask[] indicates if the corresponding bit in"]
#[doc = " sym_hash_enable_mask[] is valid or not. For the configurations gotten, it"]
#[doc = " also means if the flow type is supported by hardware or not."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hash_global_conf {
    #[doc = "< Hash function type"]
    pub hash_func: rte_eth_hash_function,
    #[doc = " Bit mask for symmetric hash enable per flow type"]
    pub sym_hash_enable_mask: [u64; 1usize],
    #[doc = " Bit mask indicates if the corresponding bit is valid"]
    pub valid_bit_mask: [u64; 1usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_global_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_global_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_global_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).hash_func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(hash_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).sym_hash_enable_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(sym_hash_enable_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).valid_bit_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(valid_bit_mask)
        )
    );
}
#[doc = " A structure used to set or get hash filter information, to support filter"]
#[doc = " type of \'RTE_ETH_FILTER_HASH\' and its operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hash_filter_info {
    #[doc = "< Information type"]
    pub info_type: rte_eth_hash_filter_info_type,
    pub info: rte_eth_hash_filter_info__bindgen_ty_1,
}
#[doc = " Details of hash filter information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_hash_filter_info__bindgen_ty_1 {
    #[doc = " For RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT"]
    pub enable: u8,
    #[doc = " Global configurations of hash filter"]
    pub global_conf: rte_eth_hash_global_conf,
    #[doc = " Global configurations of hash filter input set"]
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u64; 65usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        520usize,
        concat!("Size of: ", stringify!(rte_eth_hash_filter_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_filter_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).global_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(global_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).input_set_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info>(),
        528usize,
        concat!("Size of: ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " l2 tunnel configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_l2_tunnel_conf {
    pub l2_tunnel_type: rte_eth_tunnel_type,
    pub ether_type: u16,
    pub tunnel_id: u32,
    pub vf_id: u16,
    pub pool: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_tunnel_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_tunnel_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_tunnel_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).l2_tunnel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(l2_tunnel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).ether_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).tunnel_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).vf_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(vf_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(pool)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}rte_eth_dev_logtype"]
    pub static mut rte_eth_dev_logtype: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf {
    _unused: [u8; 0],
}
#[doc = " A structure used to retrieve statistics for an Ethernet port."]
#[doc = " Not all statistics fields in struct rte_eth_stats are supported"]
#[doc = " by any type of network interface card (NIC). If any statistics"]
#[doc = " field is not supported, its value is 0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of RX mbuf allocation failures."]
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_stats>(),
        704usize,
        concat!("Size of: ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ipackets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).opackets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ibytes as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_eth_stats), "::", stringify!(ibytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).obytes as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_eth_stats), "::", stringify!(obytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).imissed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(imissed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ierrors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ierrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).oerrors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(oerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).rx_nombuf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(rx_nombuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ipackets as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_opackets as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ibytes as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_obytes as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_errors as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_errors)
        )
    );
}
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_link {
    #[doc = "< ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_link>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_link))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_link>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_link))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_link>())).link_speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_link),
            "::",
            stringify!(link_speed)
        )
    );
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure the ring threshold registers of an RX/TX"]
#[doc = " queue for an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_thresh>(),
        3usize,
        concat!("Size of: ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_thresh>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).pthresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(pthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).hthresh as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(hthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).wthresh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(wthresh)
        )
    );
}
#[doc = " None of DCB,RSS or VMDQ mode"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
#[doc = " For RX side, only RSS is on"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
#[doc = " For RX side,only DCB is on."]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
#[doc = " Both DCB and RSS enable"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
#[doc = " Only VMDQ, no RSS nor DCB"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
#[doc = " RSS mode with VMDQ"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
#[doc = " Use VMDQ+DCB to route traffic to queues"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
#[doc = " Enable both VMDQ and DCB in VMDq"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
#[doc = "  A set of values to identify what method is to be used to route"]
#[doc = "  packets to multiple queues."]
pub type rte_eth_rx_mq_mode = u32;
#[doc = "< It is in neither DCB nor VT mode."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
#[doc = "< For TX side,only DCB is on."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
#[doc = "< For TX side,both DCB and VT is on."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
#[doc = "< Only VT on, no DCB"]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
#[doc = " A set of values to identify what method is to be used to transmit"]
#[doc = " packets using multi-TCs."]
pub type rte_eth_tx_mq_mode = u32;
#[doc = " A structure used to configure the RX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Only used if JUMBO_FRAME enabled."]
    pub max_rx_pkt_len: u32,
    #[doc = "< hdr buf size (header_split enabled)."]
    pub split_hdr_size: u16,
    #[doc = " Per-port Rx offloads to be set using DEV_RX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on rx_offload_capa field on rte_eth_dev_info"]
    #[doc = " structure are allowed to be set."]
    pub offloads: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxmode>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).max_rx_pkt_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_rx_pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).split_hdr_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(split_hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(offloads)
        )
    );
}
pub const rte_vlan_type_ETH_VLAN_TYPE_UNKNOWN: rte_vlan_type = 0;
#[doc = "< Inner VLAN."]
pub const rte_vlan_type_ETH_VLAN_TYPE_INNER: rte_vlan_type = 1;
#[doc = "< Single VLAN, or outer VLAN."]
pub const rte_vlan_type_ETH_VLAN_TYPE_OUTER: rte_vlan_type = 2;
pub const rte_vlan_type_ETH_VLAN_TYPE_MAX: rte_vlan_type = 3;
#[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN."]
#[doc = " Note that single VLAN is treated the same as inner VLAN."]
pub type rte_vlan_type = u32;
#[doc = " A structure used to describe a vlan filter."]
#[doc = " If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[test]
fn bindgen_test_layout_rte_vlan_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_vlan_filter_conf>(),
        512usize,
        concat!("Size of: ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vlan_filter_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_filter_conf>())).ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_filter_conf),
            "::",
            stringify!(ids)
        )
    );
}
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature"]
#[doc = " of an Ethernet port."]
#[doc = " If not NULL, the *rss_key* pointer of the *rss_conf* structure points"]
#[doc = " to an array holding the RSS key to use for hashing specific header"]
#[doc = " fields of received packets. The length of this array should be indicated"]
#[doc = " by *rss_key_len* below. Otherwise, a default random hash key is used by"]
#[doc = " the device driver."]
#[doc = ""]
#[doc = " The *rss_key_len* field of the *rss_conf* structure indicates the length"]
#[doc = " in bytes of the array pointed by *rss_key*. To be compatible, this length"]
#[doc = " will be checked in i40e only. Others assume 40 bytes to be used as before."]
#[doc = ""]
#[doc = " The *rss_hf* field of the *rss_conf* structure indicates the different"]
#[doc = " types of IPv4/IPv6 packets to which the RSS hashing must be applied."]
#[doc = " Supplying an *rss_hf* equal to zero disables the RSS feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = "< If not NULL, 40-byte hash key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = "< Hash functions to apply - see below."]
    pub rss_hf: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_hf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_hf)
        )
    );
}
#[doc = " A structure used to configure VLAN traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vlan_mirror {
    #[doc = "< mask for valid VLAN ID."]
    pub vlan_mask: u64,
    #[doc = " VLAN ID list for vlan mirroring."]
    pub vlan_id: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vlan_mirror() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vlan_mirror>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vlan_mirror>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_id)
        )
    );
}
#[doc = " A structure used to configure traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_mirror_conf {
    #[doc = "< Mirroring rule type"]
    pub rule_type: u8,
    #[doc = "< Destination pool for this mirror rule."]
    pub dst_pool: u8,
    #[doc = "< Bitmap of pool for pool mirroring"]
    pub pool_mask: u64,
    #[doc = " VLAN ID setting for VLAN mirroring."]
    pub vlan: rte_eth_vlan_mirror,
}
#[test]
fn bindgen_test_layout_rte_eth_mirror_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mirror_conf>(),
        152usize,
        concat!("Size of: ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mirror_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).rule_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(rule_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).dst_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(dst_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).pool_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(pool_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).vlan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(vlan)
        )
    );
}
#[doc = " A structure used to configure 64 entries of Redirection Table of the"]
#[doc = " Receive Side Scaling (RSS) feature of an Ethernet port. To configure"]
#[doc = " more than 64 entries supported by hardware, an array of this structure"]
#[doc = " is needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rss_reta_entry64() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_reta_entry64>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_reta_entry64>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).reta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(reta)
        )
    );
}
#[doc = "< 4 TCs with DCB."]
pub const rte_eth_nb_tcs_ETH_4_TCS: rte_eth_nb_tcs = 4;
#[doc = "< 8 TCs with DCB."]
pub const rte_eth_nb_tcs_ETH_8_TCS: rte_eth_nb_tcs = 8;
#[doc = " This enum indicates the possible number of traffic classes"]
#[doc = " in DCB configurations"]
pub type rte_eth_nb_tcs = u32;
#[doc = "< 8 VMDq pools."]
pub const rte_eth_nb_pools_ETH_8_POOLS: rte_eth_nb_pools = 8;
#[doc = "< 16 VMDq pools."]
pub const rte_eth_nb_pools_ETH_16_POOLS: rte_eth_nb_pools = 16;
#[doc = "< 32 VMDq pools."]
pub const rte_eth_nb_pools_ETH_32_POOLS: rte_eth_nb_pools = 32;
#[doc = "< 64 VMDq pools."]
pub const rte_eth_nb_pools_ETH_64_POOLS: rte_eth_nb_pools = 64;
#[doc = " This enum indicates the possible number of queue pools"]
#[doc = " in VMDQ configurations."]
pub type rte_eth_nb_pools = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_rx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_rx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_tx_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
}
#[doc = " A structure used to configure the VMDQ+DCB feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues, based"]
#[doc = " on the vlan id in the vlan tag, and then to a specific queue within"]
#[doc = " that pool, using the user priority vlan tag field."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the vlan filter rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).vlan_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).pools as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).enable_default_pool as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).default_pool as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_pool_maps as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).pool_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(pool_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).dcb_tc as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[doc = " A structure used to configure the VMDQ feature of an Ethernet port when"]
#[doc = " not combined with the DCB feature."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues. By default,"]
#[doc = " the pool selection is based on the MAC address, the vlan id in the"]
#[doc = " vlan tag as specified in the pool_map array."]
#[doc = " Passing the ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool"]
#[doc = " selection using only the MAC address. MAC address to pool mapping is done"]
#[doc = " using the rte_eth_dev_mac_addr_add function, with the pool parameter"]
#[doc = " corresponding to the pool id."]
#[doc = ""]
#[doc = " Queue selection within the selected pool will be done using RSS when"]
#[doc = " it is enabled or revert to the first queue of the pool if not."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the vlan filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).vlan_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).pools as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_default_pool as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).default_pool as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_loop_back as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_loop_back)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_pool_maps as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).rx_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(rx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).pool_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(pool_map)
        )
    );
}
#[doc = " A structure used to configure the TX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< TX multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    #[doc = " Per-port Tx offloads to be set using DEV_TX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on tx_offload_capa field on rte_eth_dev_info"]
    #[doc = " structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txmode>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).offloads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).pvid as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_eth_txmode), "::", stringify!(pvid))
    );
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an RX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< RX ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of RX descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = " Per-queue Rx offloads to be set using DEV_RX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on rx_queue_offload_capa or rx_offload_capa"]
    #[doc = " fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxconf>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_free_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_drop_en as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_drop_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_deferred_start as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).offloads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(offloads)
        )
    );
}
#[doc = " A structure used to configure a TX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< TX ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing TX buffers if there are"]
    #[doc = "less free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using DEV_TX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on tx_queue_offload_capa or tx_offload_capa"]
    #[doc = " fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txconf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_rs_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_rs_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_free_thresh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_deferred_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(offloads)
        )
    );
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet."]
    #[doc = ""]
    #[doc = " - For TSO packet this is the total number of data descriptors allowed"]
    #[doc = "   by device."]
    #[doc = ""]
    #[doc = " @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU."]
    #[doc = ""]
    #[doc = " - For non-TSO packet, this is the maximum allowed number of segments"]
    #[doc = "   in a single transmit packet."]
    #[doc = ""]
    #[doc = " - For TSO packet each segment within the TSO may span up to this"]
    #[doc = "   value."]
    #[doc = ""]
    #[doc = " @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_desc_lim>(),
        10usize,
        concat!("Size of: ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_desc_lim>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_min as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_seg_max as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_seg_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_mtu_seg_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_mtu_seg_max)
        )
    );
}
#[doc = "< Disable flow control."]
pub const rte_eth_fc_mode_RTE_FC_NONE: rte_eth_fc_mode = 0;
#[doc = "< RX pause frame, enable flowctrl on TX side."]
pub const rte_eth_fc_mode_RTE_FC_RX_PAUSE: rte_eth_fc_mode = 1;
#[doc = "< TX pause frame, enable flowctrl on RX side."]
pub const rte_eth_fc_mode_RTE_FC_TX_PAUSE: rte_eth_fc_mode = 2;
#[doc = "< Enable flow control on both side."]
pub const rte_eth_fc_mode_RTE_FC_FULL: rte_eth_fc_mode = 3;
#[doc = " This enum indicates the flow control mode"]
pub type rte_eth_fc_mode = u32;
#[doc = " A structure used to configure Ethernet flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fc_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).high_water as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(high_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).low_water as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(low_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).pause_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(pause_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).send_xon as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(send_xon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).mode as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(rte_eth_fc_conf), "::", stringify!(mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).mac_ctrl_frame_fwd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mac_ctrl_frame_fwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).autoneg as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(autoneg)
        )
    );
}
#[doc = " A structure used to configure Ethernet priority flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_pfc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_pfc_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_pfc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).fc as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_pfc_conf), "::", stringify!(fc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(priority)
        )
    );
}
#[doc = "< 64k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_64K: rte_fdir_pballoc_type = 0;
#[doc = "< 128k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_128K: rte_fdir_pballoc_type = 1;
#[doc = "< 256k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_256K: rte_fdir_pballoc_type = 2;
#[doc = "  Memory space that can be configured to store Flow Director filters"]
#[doc = "  in the board memory."]
pub type rte_fdir_pballoc_type = u32;
#[doc = "< Never report FDIR hash."]
pub const rte_fdir_status_mode_RTE_FDIR_NO_REPORT_STATUS: rte_fdir_status_mode = 0;
#[doc = "< Only report FDIR hash for matching pkts."]
pub const rte_fdir_status_mode_RTE_FDIR_REPORT_STATUS: rte_fdir_status_mode = 1;
#[doc = "< Always report FDIR hash."]
pub const rte_fdir_status_mode_RTE_FDIR_REPORT_STATUS_ALWAYS: rte_fdir_status_mode = 2;
#[doc = "  Select report mode of FDIR hash information in RX descriptors."]
pub type rte_fdir_status_mode = u32;
#[doc = " A structure used to configure the Flow Director (FDIR) feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " If mode is RTE_FDIR_DISABLE, the pballoc value is ignored."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fdir_conf {
    #[doc = "< Flow Director mode."]
    pub mode: rte_fdir_mode,
    #[doc = "< Space for FDIR filters."]
    pub pballoc: rte_fdir_pballoc_type,
    #[doc = "< How to report FDIR hash."]
    pub status: rte_fdir_status_mode,
    #[doc = " RX queue of packets matching a \"drop\" filter in perfect mode."]
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[test]
fn bindgen_test_layout_rte_fdir_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_fdir_conf>(),
        792usize,
        concat!("Size of: ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fdir_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mode as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_fdir_conf), "::", stringify!(mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).pballoc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(pballoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).status as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_fdir_conf), "::", stringify!(status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).drop_queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(drop_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mask as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_fdir_conf), "::", stringify!(mask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).flex_conf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(flex_conf)
        )
    );
}
#[doc = " UDP tunneling configuration."]
#[doc = " Used to config the UDP port for a type of tunnel."]
#[doc = " NICs need the UDP port to identify the tunnel type."]
#[doc = " Normally a type of tunnel has a default UDP port, this structure can be used"]
#[doc = " in case if the users want to change or support more UDP port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. Defined in rte_eth_tunnel_type."]
    pub prot_type: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_udp_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udp_tunnel>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udp_tunnel>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).udp_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(udp_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).prot_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(prot_type)
        )
    );
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_intr_conf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_intr_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_conf))
    );
}
impl rte_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port."]
#[doc = " Depending upon the RX multi-queue mode, extra advanced"]
#[doc = " configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of ETH_LINK_SPEED_XXX of speeds to be"]
    #[doc = "used. ETH_LINK_SPEED_FIXED disables link"]
    #[doc = "autonegotiation, and a unique speed shall be"]
    #[doc = "set. Otherwise, the bitmap defines the set of"]
    #[doc = "speeds to be advertised. If the special value"]
    #[doc = "ETH_LINK_SPEED_AUTONEG (0) is used, all speeds"]
    #[doc = "supported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port RX configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port TX configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value"]
    #[doc = "is 0, meaning the loopback mode is disabled."]
    #[doc = "Read the datasheet of given ethernet controller"]
    #[doc = "for details. The possible values of this field"]
    #[doc = "are defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port RX filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port TX DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC"]
    #[doc = "is needed,and the variable must be set ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< FDIR configuration."]
    pub fdir_conf: rte_fdir_conf,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>(),
        2120usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).rss_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(rss_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_dcb_conf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_dcb_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).dcb_rx_conf as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(dcb_rx_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_rx_conf as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_rx_conf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_dcb_tx_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).dcb_tx_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_tx_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_tx_conf)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf>(),
        3000usize,
        concat!("Size of: ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).link_speeds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(link_speeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rxmode as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_eth_conf), "::", stringify!(rxmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).txmode as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_eth_conf), "::", stringify!(txmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).lpbk_mode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(lpbk_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rx_adv_conf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).tx_adv_conf as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(tx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).dcb_capability_en as *const _ as usize },
        2196usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(dcb_capability_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).fdir_conf as *const _ as usize },
        2200usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(fdir_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).intr_conf as *const _ as usize },
        2992usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(intr_conf)
        )
    );
}
#[doc = " Preferred Rx/Tx port parameters."]
#[doc = " There are separate instances of this structure for transmission"]
#[doc = " and reception respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_portconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_portconf>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_portconf>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).burst_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(burst_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).ring_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).nb_queues as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(nb_queues)
        )
    );
}
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain id"]
    pub domain_id: u16,
    pub port_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_switch_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_switch_info>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_switch_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).domain_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).port_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(port_id)
        )
    );
}
#[doc = " A structure used to retrieve the contextual information of"]
#[doc = " an Ethernet device, such as the controlling driver of the"]
#[doc = " device, etc..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_info {
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none."]
    #[doc = "Use if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = "< Minimum size of RX buffer."]
    pub min_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of RX pkt."]
    pub max_rx_pktlen: u32,
    #[doc = "< Maximum number of RX queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of TX queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    pub rx_offload_capa: u64,
    pub tx_offload_capa: u64,
    pub rx_queue_offload_capa: u64,
    pub tx_queue_offload_capa: u64,
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    #[doc = " Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default RX configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default TX configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDQ pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDQ pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDQ pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< RX descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< TX descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of RX queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of TX queues."]
    pub nb_tx_queues: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a"]
    #[doc = " embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_info>(),
        216usize,
        concat!("Size of: ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).driver_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(driver_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).if_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(if_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).min_rx_bufsize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_rx_bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_pktlen as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_pktlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_queues as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_tx_queues as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_mac_addrs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_hash_mac_addrs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vfs as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vmdq_pools as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vmdq_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_offload_capa as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_offload_capa as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_queue_offload_capa as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_queue_offload_capa as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reta_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reta_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).hash_key_size as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(hash_key_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).flow_type_rss_offloads as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(flow_type_rss_offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxconf as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txconf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_base as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_num as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_pool_base as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_pool_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_desc_lim as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_desc_lim as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).speed_capa as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(speed_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_rx_queues as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_tx_queues as *const _ as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxportconf as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxportconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txportconf as *const _ as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txportconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_capa as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).switch_info as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(switch_info)
        )
    );
}
#[doc = " Ethernet device RX queue information structure."]
#[doc = " Used to retieve information about configured queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets RX supported."]
    pub scattered_rx: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_rxq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxq_info>(),
        32usize,
        concat!("Size of: ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxq_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).mp as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_rxq_info), "::", stringify!(mp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).conf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).scattered_rx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(scattered_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).nb_desc as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
#[doc = " Ethernet device TX queue information structure."]
#[doc = " Used to retrieve information about configured queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_txq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txq_info>(),
        32usize,
        concat!("Size of: ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txq_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).nb_desc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
#[doc = " An Ethernet device extended statistic structure"]
#[doc = ""]
#[doc = " This structure is used by rte_eth_xstats_get() to provide"]
#[doc = " statistics that are not provided in the generic *rte_eth_stats*"]
#[doc = " structure."]
#[doc = " It maps a name id, corresponding to an index in the array returned"]
#[doc = " by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_xstat() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_xstat), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).value as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_eth_xstat), "::", stringify!(value))
    );
}
#[doc = " A name element for extended statistics."]
#[doc = ""]
#[doc = " An array of this structure is returned by rte_eth_xstats_get_names()."]
#[doc = " It lists the names of extended statistics for a PMD. The *rte_eth_xstat*"]
#[doc = " structure references these names by their array index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_xstat_name() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat_name>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat_name>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat_name>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat_name),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " A structure used to get the information of queue and"]
#[doc = " TC mapping on both TX and RX paths."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).nb_queue as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).nb_queue as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>(),
        2048usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_rxq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_rxq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_txq as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_txq)
        )
    );
}
#[doc = " A structure used to get the information of DCB."]
#[doc = " It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< TX BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_info>(),
        2065usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).prio_tc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(prio_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_bws as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_bws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_queue as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_queue)
        )
    );
}
#[doc = " Function type used for RX packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on RX with a burst of packets that have"]
#[doc = " been received on the given port and queue."]
#[doc = ""]
#[doc = " @param port_id"]
#[doc = "   The Ethernet port on which RX is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to receive the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that have just been received."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param max_pkts"]
#[doc = "   The max number of packets that can be stored in the \"pkts\" array."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for TX packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on TX with a burst of packets immediately"]
#[doc = " before the packets are put onto the hardware queue for transmission."]
#[doc = ""]
#[doc = " @param port_id"]
#[doc = "   The Ethernet port on which TX is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to transmit the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that are about to be transmitted."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Device is unused before being probed."]
pub const rte_eth_dev_state_RTE_ETH_DEV_UNUSED: rte_eth_dev_state = 0;
#[doc = " Device is attached when allocated in probing."]
pub const rte_eth_dev_state_RTE_ETH_DEV_ATTACHED: rte_eth_dev_state = 1;
#[doc = " Device is in removed state when plug-out is detected."]
pub const rte_eth_dev_state_RTE_ETH_DEV_REMOVED: rte_eth_dev_state = 2;
#[doc = " Possible states of an ethdev port."]
pub type rte_eth_dev_state = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_sriov() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_sriov>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_sriov>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).nb_q_per_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(nb_q_per_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_vmdq_idx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_vmdq_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_pool_q_idx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_pool_q_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_owner {
    #[doc = "< The owner unique identifier."]
    pub id: u64,
    #[doc = "< The owner name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_owner() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_owner>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_owner>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_dev_owner), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_owner),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[doc = " Iterates over valid ethdev ports owned by a specific owner."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The id of the next possible valid owned port."]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = "  RTE_ETH_DEV_NO_OWNER means iterate over all valid ownerless ports."]
    #[doc = " @return"]
    #[doc = "   Next valid port id owned by owner_id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_owned_by(port_id: u16, owner_id: u64) -> u64;
}
extern "C" {
    #[doc = " Iterates over valid ethdev ports."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The id of the next possible valid port."]
    #[doc = " @return"]
    #[doc = "   Next valid port id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next(port_id: u16) -> u16;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get a new unique owner identifier."]
    #[doc = " An owner identifier is used to owns Ethernet devices by only one DPDK entity"]
    #[doc = " to avoid multiple management of device by different entities."]
    #[doc = ""]
    #[doc = " @param\towner_id"]
    #[doc = "   Owner identifier pointer."]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_new(owner_id: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Set an Ethernet device owner."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The identifier of the port to own."]
    #[doc = " @param\towner"]
    #[doc = "  The owner pointer."]
    #[doc = " @return"]
    #[doc = "  Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_set(port_id: u16, owner: *const rte_eth_dev_owner) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Unset Ethernet device owner to make the device ownerless."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The identifier of port to make ownerless."]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_unset(port_id: u16, owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Remove owner from all Ethernet devices owned by a specific owner."]
    #[doc = ""]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    pub fn rte_eth_dev_owner_delete(owner_id: u64);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get the owner of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The port identifier."]
    #[doc = " @param\towner"]
    #[doc = "  The owner structure pointer to fill."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error.."]
    pub fn rte_eth_dev_owner_get(port_id: u16, owner: *mut rte_eth_dev_owner) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the total number of Ethernet devices that have been successfully"]
    #[doc = " initialized by the matching Ethernet driver during the PCI probing phase"]
    #[doc = " and that are available for applications to use. These devices must be"]
    #[doc = " accessed by using the ``RTE_ETH_FOREACH_DEV()`` macro to deal with"]
    #[doc = " non-contiguous ranges of devices."]
    #[doc = " These non-contiguous ranges can be created by calls to hotplug functions or"]
    #[doc = " by some PMDs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - The total number of usable Ethernet devices."]
    pub fn rte_eth_dev_count() -> u16;
}
extern "C" {
    #[doc = " Get the number of ports which are usable for the application."]
    #[doc = ""]
    #[doc = " These devices must be iterated by using the macro"]
    #[doc = " ``RTE_ETH_FOREACH_DEV`` or ``RTE_ETH_FOREACH_DEV_OWNED_BY``"]
    #[doc = " to deal with non-contiguous ranges of devices."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The count of available Ethernet devices."]
    pub fn rte_eth_dev_count_avail() -> u16;
}
extern "C" {
    #[doc = " Get the total number of ports which are allocated."]
    #[doc = ""]
    #[doc = " Some devices may not be available for the application."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total count of Ethernet devices."]
    pub fn rte_eth_dev_count_total() -> u16;
}
extern "C" {
    #[doc = " Convert a numerical speed in Mbps to a bitmap flag that can be used in"]
    #[doc = " the bitmap link_speeds of the struct rte_eth_conf"]
    #[doc = ""]
    #[doc = " @param speed"]
    #[doc = "   Numerical speed value in Mbps"]
    #[doc = " @param duplex"]
    #[doc = "   ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)"]
    #[doc = " @return"]
    #[doc = "   0 if the speed cannot be mapped"]
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[doc = " Get DEV_RX_OFFLOAD_* flag name."]
    #[doc = ""]
    #[doc = " @param offload"]
    #[doc = "   Offload flag."]
    #[doc = " @return"]
    #[doc = "   Offload name or \'UNKNOWN\' if the flag cannot be recognised."]
    pub fn rte_eth_dev_rx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get DEV_TX_OFFLOAD_* flag name."]
    #[doc = ""]
    #[doc = " @param offload"]
    #[doc = "   Offload flag."]
    #[doc = " @return"]
    #[doc = "   Offload name or \'UNKNOWN\' if the flag cannot be recognised."]
    pub fn rte_eth_dev_tx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Configure an Ethernet device."]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " Ethernet API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device to configure."]
    #[doc = " @param nb_rx_queue"]
    #[doc = "   The number of receive queues to set up for the Ethernet device."]
    #[doc = " @param nb_tx_queue"]
    #[doc = "   The number of transmit queues to set up for the Ethernet device."]
    #[doc = " @param eth_conf"]
    #[doc = "   The pointer to the configuration data to be used for the Ethernet device."]
    #[doc = "   The *rte_eth_conf* structure includes:"]
    #[doc = "     -  the hardware offload features to activate, with dedicated fields for"]
    #[doc = "        each statically configurable offload hardware feature provided by"]
    #[doc = "        Ethernet devices, such as IP checksum or VLAN tag stripping for"]
    #[doc = "        example."]
    #[doc = "        The Rx offload bitfield API is obsolete and will be deprecated."]
    #[doc = "        Applications should set the ignore_bitfield_offloads bit on *rxmode*"]
    #[doc = "        structure and use offloads field to set per-port offloads instead."]
    #[doc = "     -  Any offloading set in eth_conf->[rt]xmode.offloads must be within"]
    #[doc = "        the [rt]x_offload_capa returned from rte_eth_dev_infos_get()."]
    #[doc = "        Any type of device supported offloading set in the input argument"]
    #[doc = "        eth_conf->[rt]xmode.offloads to rte_eth_dev_configure() is enabled"]
    #[doc = "        on all queues and it can\'t be disabled in rte_eth_[rt]x_queue_setup()"]
    #[doc = "     -  the Receive Side Scaling (RSS) configuration when using multiple RX"]
    #[doc = "        queues per port. Any RSS hash function set in eth_conf->rss_conf.rss_hf"]
    #[doc = "        must be within the flow_type_rss_offloads provided by drivers via"]
    #[doc = "        rte_eth_dev_infos_get() API."]
    #[doc = ""]
    #[doc = "   Embedding all configuration information in a single data structure"]
    #[doc = "   is the more flexible method that allows the addition of new features"]
    #[doc = "   without changing the syntax of the API."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured."]
    #[doc = "   - <0: Error code returned by the driver configuration function."]
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Check if an Ethernet device was physically removed."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   1 when the Ethernet device is removed, otherwise 0."]
    pub fn rte_eth_dev_is_removed(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a receive queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " The function allocates a contiguous block of memory for *nb_rx_desc*"]
    #[doc = " receive descriptors from a memory zone associated with *socket_id*"]
    #[doc = " and initializes each receive descriptor with a network buffer allocated"]
    #[doc = " from the memory pool *mb_pool*."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue to set up."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   The number of receive descriptors to allocate for the receive ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the receive descriptors of the ring."]
    #[doc = " @param rx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the receive queue."]
    #[doc = "   NULL value is allowed, in which case default RX configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *rx_conf* structure contains an *rx_thresh* structure with the values"]
    #[doc = "   of the Prefetch, Host, and Write-Back threshold registers of the receive"]
    #[doc = "   ring."]
    #[doc = "   In addition it contains the hardware offloads features to activate using"]
    #[doc = "   the DEV_RX_OFFLOAD_* flags."]
    #[doc = "   If an offloading set in rx_conf->offloads"]
    #[doc = "   hasn\'t been set in the input argument eth_conf->rxmode.offloads"]
    #[doc = "   to rte_eth_dev_configure(), it is a new added offloading, it must be"]
    #[doc = "   per-queue type and it is enabled for the queue."]
    #[doc = "   No need to repeat any bit in rx_conf->offloads which has already been"]
    #[doc = "   enabled in rte_eth_dev_configure() at port level. An offloading enabled"]
    #[doc = "   at port level can\'t be disabled at queue level."]
    #[doc = " @param mb_pool"]
    #[doc = "   The pointer to the memory pool from which to allocate *rte_mbuf* network"]
    #[doc = "   memory buffers to populate each descriptor of the receive ring."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, receive queue correctly set up."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -EINVAL: The size of network buffers which can be allocated from the"]
    #[doc = "      memory pool does not fit the various buffer sizes allowed by the"]
    #[doc = "      device controller."]
    #[doc = "   - -ENOMEM: Unable to allocate the receive ring descriptors or to"]
    #[doc = "      allocate network memory buffers from the memory pool when"]
    #[doc = "      initializing receive descriptors."]
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a transmit queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue to set up."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   The number of transmit descriptors to allocate for the transmit ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the transmit descriptors of the ring."]
    #[doc = " @param tx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the transmit queue."]
    #[doc = "   NULL value is allowed, in which case default TX configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *tx_conf* structure contains the following data:"]
    #[doc = "   - The *tx_thresh* structure with the values of the Prefetch, Host, and"]
    #[doc = "     Write-Back threshold registers of the transmit ring."]
    #[doc = "     When setting Write-Back threshold to the value greater then zero,"]
    #[doc = "     *tx_rs_thresh* value should be explicitly set to one."]
    #[doc = "   - The *tx_free_thresh* value indicates the [minimum] number of network"]
    #[doc = "     buffers that must be pending in the transmit ring to trigger their"]
    #[doc = "     [implicit] freeing by the driver transmit function."]
    #[doc = "   - The *tx_rs_thresh* value indicates the [minimum] number of transmit"]
    #[doc = "     descriptors that must be pending in the transmit ring before setting the"]
    #[doc = "     RS bit on a descriptor by the driver transmit function."]
    #[doc = "     The *tx_rs_thresh* value should be less or equal then"]
    #[doc = "     *tx_free_thresh* value, and both of them should be less then"]
    #[doc = "     *nb_tx_desc* - 3."]
    #[doc = "   - The *offloads* member contains Tx offloads to be enabled."]
    #[doc = "     If an offloading set in tx_conf->offloads"]
    #[doc = "     hasn\'t been set in the input argument eth_conf->txmode.offloads"]
    #[doc = "     to rte_eth_dev_configure(), it is a new added offloading, it must be"]
    #[doc = "     per-queue type and it is enabled for the queue."]
    #[doc = "     No need to repeat any bit in tx_conf->offloads which has already been"]
    #[doc = "     enabled in rte_eth_dev_configure() at port level. An offloading enabled"]
    #[doc = "     at port level can\'t be disabled at queue level."]
    #[doc = ""]
    #[doc = "     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces"]
    #[doc = "     the transmit function to use default values."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is correctly set up."]
    #[doc = "   - -ENOMEM: Unable to allocate the transmit ring descriptors."]
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the NUMA socket to which an Ethernet device is connected"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   The NUMA socket id to which the Ethernet device is connected or"]
    #[doc = "   a default of zero if the socket could not be determined."]
    #[doc = "   -1 is returned is the port_id value is out of range."]
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if port_id of device is attached"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - 0 if port is out of range or not attached"]
    #[doc = "   - 1 if device is attached"]
    pub fn rte_eth_dev_is_valid_port(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start specified RX queue of a port. It is used when rx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is started."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_start(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified RX queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is stopped."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_stop(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start TX for specified queue of a port. It is used when tx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is started."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_start(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified TX queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is stopped."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_stop(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an Ethernet device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the configured"]
    #[doc = " offload features and in starting the transmit and the receive units of the"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before"]
    #[doc = " PMD port start callback function is invoked."]
    #[doc = ""]
    #[doc = " On success, all basic functions exported by the Ethernet API (link status,"]
    #[doc = " receive/transmit, and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device started."]
    #[doc = "   - <0: Error code of the driver device start function."]
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop an Ethernet device. The device can be restarted with a call to"]
    #[doc = " rte_eth_dev_start()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_stop(port_id: u16);
}
extern "C" {
    #[doc = " Link up an Ethernet device."]
    #[doc = ""]
    #[doc = " Set device link up will re-enable the device rx/tx"]
    #[doc = " functionality after it is previously set device linked down."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device linked up."]
    #[doc = "   - <0: Error code of the driver device link up function."]
    pub fn rte_eth_dev_set_link_up(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link down an Ethernet device."]
    #[doc = " The device rx/tx functionality will be disabled if success,"]
    #[doc = " and it can be re-enabled with a call to"]
    #[doc = " rte_eth_dev_set_link_up()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_set_link_down(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a stopped Ethernet device. The device cannot be restarted!"]
    #[doc = " The function frees all port resources if the driver supports"]
    #[doc = " the flag RTE_ETH_DEV_CLOSE_REMOVE."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_close(port_id: u16);
}
extern "C" {
    #[doc = " Reset a Ethernet device and keep its port id."]
    #[doc = ""]
    #[doc = " When a port has to be reset passively, the DPDK application can invoke"]
    #[doc = " this function. For example when a PF is reset, all its VFs should also"]
    #[doc = " be reset. Normally a DPDK application can invoke this function when"]
    #[doc = " RTE_ETH_EVENT_INTR_RESET event is detected, but can also use it to start"]
    #[doc = " a port reset in other circumstances."]
    #[doc = ""]
    #[doc = " When this function is called, it first stops the port and then calls the"]
    #[doc = " PMD specific dev_uninit( ) and dev_init( ) to return the port to initial"]
    #[doc = " state, in which no Tx and Rx queues are setup, as if the port has been"]
    #[doc = " reset and not started. The port keeps the port id it had before the"]
    #[doc = " function call."]
    #[doc = ""]
    #[doc = " After calling rte_eth_dev_reset( ), the application should use"]
    #[doc = " rte_eth_dev_configure( ), rte_eth_rx_queue_setup( ),"]
    #[doc = " rte_eth_tx_queue_setup( ), and rte_eth_dev_start( )"]
    #[doc = " to reconfigure the device as appropriate."]
    #[doc = ""]
    #[doc = " Note: To avoid unexpected behavior, the application should stop calling"]
    #[doc = " Tx and Rx functions before calling rte_eth_dev_reset( ). For thread"]
    #[doc = " safety, all these controlling functions should be called from the same"]
    #[doc = " thread."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-EINVAL) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn\'t support this function."]
    #[doc = "   - (-EPERM) if not ran from the primary process."]
    #[doc = "   - (-EIO) if re-initialisation failed or device is removed."]
    #[doc = "   - (-ENOMEM) if the reset failed due to OOM."]
    #[doc = "   - (-EAGAIN) if the reset temporarily failed and should be retried later."]
    pub fn rte_eth_dev_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_promiscuous_enable(port_id: u16);
}
extern "C" {
    #[doc = " Disable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_promiscuous_disable(port_id: u16);
}
extern "C" {
    #[doc = " Return the value of promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if promiscuous is enabled"]
    #[doc = "   - (0) if promiscuous is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_promiscuous_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable the receipt of any multicast frame by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_allmulticast_enable(port_id: u16);
}
extern "C" {
    #[doc = " Disable the receipt of all multicast frames by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_allmulticast_disable(port_id: u16);
}
extern "C" {
    #[doc = " Return the value of allmulticast mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if allmulticast is enabled"]
    #[doc = "   - (0) if allmulticast is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_allmulticast_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX"]
    #[doc = " or FULL-DUPLEX) of the physical link of an Ethernet device. It might need"]
    #[doc = " to wait up to 9 seconds in it."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   A pointer to an *rte_eth_link* structure to be filled with"]
    #[doc = "   the status, the speed and the mode of the Ethernet device link."]
    pub fn rte_eth_link_get(port_id: u16, link: *mut rte_eth_link);
}
extern "C" {
    #[doc = " Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX"]
    #[doc = " or FULL-DUPLEX) of the physical link of an Ethernet device. It is a no-wait"]
    #[doc = " version of rte_eth_link_get()."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   A pointer to an *rte_eth_link* structure to be filled with"]
    #[doc = "   the status, the speed and the mode of the Ethernet device link."]
    pub fn rte_eth_link_get_nowait(port_id: u16, link: *mut rte_eth_link);
}
extern "C" {
    #[doc = " Retrieve the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param stats"]
    #[doc = "   A pointer to a structure of type *rte_eth_stats* to be filled with"]
    #[doc = "   the values of device counters for the following set of statistics:"]
    #[doc = "   - *ipackets* with the total of successfully received packets."]
    #[doc = "   - *opackets* with the total of successfully transmitted packets."]
    #[doc = "   - *ibytes*   with the total of successfully received bytes."]
    #[doc = "   - *obytes*   with the total of successfully transmitted bytes."]
    #[doc = "   - *ierrors*  with the total of erroneous received packets."]
    #[doc = "   - *oerrors*  with the total of failed transmitted packets."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if device notified to reset stats."]
    #[doc = "   - (-ENOTSUP) if hardware doesn\'t support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_stats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " There is an assumption that \'xstat_names\' and \'xstats\' arrays are matched"]
    #[doc = " by array index:"]
    #[doc = "  xstats_names[i].name => xstats[i].value"]
    #[doc = ""]
    #[doc = " And the array index is same with id field of \'struct rte_eth_xstat\':"]
    #[doc = "  xstats[i].id == i"]
    #[doc = ""]
    #[doc = " This assumption makes key-value pair matching less flexible but simpler."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   An rte_eth_xstat_name array of at least *size* elements to"]
    #[doc = "   be filled. If set to NULL, the function returns the required number"]
    #[doc = "   of elements."]
    #[doc = " @param size"]
    #[doc = "   The size of the xstats_names array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " There is an assumption that \'xstat_names\' and \'xstats\' arrays are matched"]
    #[doc = " by array index:"]
    #[doc = "  xstats_names[i].name => xstats[i].value"]
    #[doc = ""]
    #[doc = " And the array index is same with id field of \'struct rte_eth_xstat\':"]
    #[doc = "  xstats[i].id == i"]
    #[doc = ""]
    #[doc = " This assumption makes key-value pair matching less flexible but simpler."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats"]
    #[doc = "   A pointer to a table of structure of type *rte_eth_xstat*"]
    #[doc = "   to be filled with device statistics ids and values."]
    #[doc = "   This parameter can be set to NULL if n is 0."]
    #[doc = " @param n"]
    #[doc = "   The size of the xstats array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to n: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than n: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get(
        port_id: u16,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   An rte_eth_xstat_name array of at least *size* elements to"]
    #[doc = "   be filled. If set to NULL, the function returns the required number"]
    #[doc = "   of elements."]
    #[doc = " @param ids"]
    #[doc = "   IDs array given by app to retrieve specific statistics"]
    #[doc = " @param size"]
    #[doc = "   The size of the xstats_names array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ids"]
    #[doc = "   A pointer to an ids array passed by application. This tells which"]
    #[doc = "   statistics values function should retrieve. This parameter"]
    #[doc = "   can be set to NULL if size is 0. In this case function will retrieve"]
    #[doc = "   all avalible statistics."]
    #[doc = " @param values"]
    #[doc = "   A pointer to a table to be filled with device statistics values."]
    #[doc = " @param size"]
    #[doc = "   The size of the ids array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_by_id(
        port_id: u16,
        ids: *const u64,
        values: *mut u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the ID of a statistic from its name."]
    #[doc = ""]
    #[doc = " This function searches for the statistics using string compares, and"]
    #[doc = " as such should not be used on the fast-path. For fast-path retrieval of"]
    #[doc = " specific statistics, store the ID as provided in *id* from this function,"]
    #[doc = " and pass the ID to rte_eth_xstats_get()"]
    #[doc = ""]
    #[doc = " @param port_id The port to look up statistics from"]
    #[doc = " @param xstat_name The name of the statistic to return"]
    #[doc = " @param[out] id A pointer to an app-supplied uint64_t which should be"]
    #[doc = "                set to the ID of the stat if the stat exists."]
    #[doc = " @return"]
    #[doc = "    0 on success"]
    #[doc = "    -ENODEV for invalid port_id,"]
    #[doc = "    -EIO if device is removed,"]
    #[doc = "    -EINVAL if the xstat_name doesn\'t exist in port_id"]
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u16,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_xstats_reset(port_id: u16);
}
extern "C" {
    #[doc = "  Set a mapping for the specified transmit queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the transmit"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u16,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a mapping for the specified receive queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the receive"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u16,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the Ethernet address of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   A pointer to a structure of type *ether_addr* to be filled with"]
    #[doc = "   the Ethernet address of the Ethernet device."]
    pub fn rte_eth_macaddr_get(port_id: u16, mac_addr: *mut ether_addr);
}
extern "C" {
    #[doc = " Retrieve the contextual information of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dev_info"]
    #[doc = "   A pointer to a structure of type *rte_eth_dev_info* to be filled with"]
    #[doc = "   the contextual information of the Ethernet device."]
    pub fn rte_eth_dev_info_get(port_id: u16, dev_info: *mut rte_eth_dev_info);
}
extern "C" {
    #[doc = " Retrieve the firmware version of a device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param fw_version"]
    #[doc = "   A pointer to a string array storing the firmware version of a device,"]
    #[doc = "   the string includes terminating null. This pointer is allocated by caller."]
    #[doc = " @param fw_size"]
    #[doc = "   The size of the string array pointed by fw_version, which should be"]
    #[doc = "   large enough to store firmware version of the device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (>0) if *fw_size* is not enough to store firmware version, return"]
    #[doc = "          the size of the non truncated string."]
    pub fn rte_eth_dev_fw_version_get(
        port_id: u16,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the supported packet types of an Ethernet device."]
    #[doc = ""]
    #[doc = " When a packet type is announced as supported, it *must* be recognized by"]
    #[doc = " the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = " and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following"]
    #[doc = " packet types for these packets:"]
    #[doc = " - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/Vlan/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER"]
    #[doc = " - Ether/Vlan/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = ""]
    #[doc = " When a packet is received by a PMD, the most precise type must be"]
    #[doc = " returned among the ones supported. However a PMD is allowed to set"]
    #[doc = " packet type that is not in the supported list, at the condition that it"]
    #[doc = " is more precise. Therefore, a PMD announcing no supported packet types"]
    #[doc = " can still set a matching packet type in a received packet."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Better to invoke this API after the device is already started or rx burst"]
    #[doc = "   function is decided, to obtain correct supported ptypes."]
    #[doc = " @note"]
    #[doc = "   if a given PMD does not report what ptypes it supports, then the supported"]
    #[doc = "   ptype count is reported as 0."]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ptype_mask"]
    #[doc = "   A hint of what kind of packet type which the caller is interested in."]
    #[doc = " @param ptypes"]
    #[doc = "   An array pointer to store adequate packet types, allocated by caller."]
    #[doc = " @param num"]
    #[doc = "  Size of the array pointed by param ptypes."]
    #[doc = " @return"]
    #[doc = "   - (>=0) Number of supported ptypes. If the number of types exceeds num,"]
    #[doc = "           only num entries will be filled into the ptypes array, but the full"]
    #[doc = "           count of supported ptypes will be returned."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u16,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A pointer to a uint16_t where the retrieved MTU is to be stored."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_mtu(port_id: u16, mtu: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A uint16_t for the MTU to be applied."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if *mtu* invalid."]
    #[doc = "   - (-EBUSY) if operation is not allowed when the port is running"]
    pub fn rte_eth_dev_set_mtu(port_id: u16, mtu: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware filtering by an Ethernet device of received"]
    #[doc = " VLAN packets tagged with a given VLAN Tag Identifier."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_id"]
    #[doc = "   The VLAN Tag Identifier whose filtering must be enabled or disabled."]
    #[doc = " @param on"]
    #[doc = "   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = "   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOSYS) if VLAN filtering on *port_id* disabled."]
    #[doc = "   - (-EINVAL) if *vlan_id* > 4095."]
    pub fn rte_eth_dev_vlan_filter(port_id: u16, vlan_id: u16, on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device."]
    #[doc = " 82599/X540/X550 can support VLAN stripping at the rx queue level"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param on"]
    #[doc = "   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = "   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN stripping not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if *rx_queue_id* invalid."]
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u16,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to"]
    #[doc = " the VLAN Header. This is a register setup available on some Intel NIC, not"]
    #[doc = " but all, please check the data sheet for availability."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_type"]
    #[doc = "   The vlan type."]
    #[doc = " @param tag_type"]
    #[doc = "   The Tag Protocol ID"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN TPID setup is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u16,
        vlan_type: rte_vlan_type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set VLAN offload configuration on an Ethernet device"]
    #[doc = " Enable/Disable Extended VLAN by an Ethernet device, This is a register setup"]
    #[doc = " available on some Intel NIC, not but all, please check the data sheet for"]
    #[doc = " availability."]
    #[doc = " Enable/Disable VLAN Strip can be done on rx queue for certain NIC, but here"]
    #[doc = " the configuration is applied on the port level."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param offload_mask"]
    #[doc = "   The VLAN Offload bit mask can be mixed use with \"OR\""]
    #[doc = "       ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_offload(port_id: u16, offload_mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read VLAN Offload configuration from an Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (>0) if successful. Bit mask to indicate"]
    #[doc = "       ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_vlan_offload(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set port based TX VLAN insertion on or off."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The port identifier of the Ethernet device."]
    #[doc = " @param pvid"]
    #[doc = "  Port based TX VLAN identifier together with user priority."]
    #[doc = " @param on"]
    #[doc = "  Turn on or off the port based TX VLAN insertion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - negative if failed."]
    pub fn rte_eth_dev_set_vlan_pvid(port_id: u16, pvid: u16, on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(unsent: *mut *mut rte_mbuf, count: u16, userdata: *mut ::std::os::raw::c_void),
>;
#[doc = " Structure used to buffer packets for future TX"]
#[doc = " Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Size of buffer for buffered tx"]
    pub size: u16,
    #[doc = "< Number of packets in the array"]
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_tx_buffer() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_tx_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_dev_tx_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_tx_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_tx_buffer))
    );
}
extern "C" {
    #[doc = " Initialize default values for buffered transmitting"]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   Tx buffer to be initialized."]
    #[doc = " @param size"]
    #[doc = "   Buffer size"]
    #[doc = " @return"]
    #[doc = "   0 if no error"]
    pub fn rte_eth_tx_buffer_init(buffer: *mut rte_eth_dev_tx_buffer, size: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure a callback for buffered packets which cannot be sent"]
    #[doc = ""]
    #[doc = " Register a specific callback to be called when an attempt is made to send"]
    #[doc = " all packets buffered on an ethernet port, but not all packets can"]
    #[doc = " successfully be sent. The callback registered here will be called only"]
    #[doc = " from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs."]
    #[doc = " The default callback configured for each queue by default just frees the"]
    #[doc = " packets back to the calling mempool. If additional behaviour is required,"]
    #[doc = " for example, to count dropped packets, or to retry transmission of packets"]
    #[doc = " which cannot be sent, this function should be used to register a suitable"]
    #[doc = " callback function to implement the desired behaviour."]
    #[doc = " The example callback \"rte_eth_count_unsent_packet_callback()\" is also"]
    #[doc = " provided as reference."]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param callback"]
    #[doc = "   The function to be used as the callback."]
    #[doc = " @param userdata"]
    #[doc = "   Arbitrary parameter to be passed to the callback function"]
    #[doc = " @return"]
    #[doc = "   0 on success, or -1 on error with rte_errno set appropriately"]
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Callback function for silently dropping unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets silently and is used by tx buffered"]
    #[doc = " operations as default behavior."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Not used"]
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Callback function for tracking unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets, but also updates a user-supplied counter"]
    #[doc = " to track the overall number of packets dropped. The counter should be an"]
    #[doc = " uint64_t variable."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Pointer to an uint64_t value, which will be incremented by unsent"]
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Request the driver to free mbufs currently cached by the driver. The"]
    #[doc = " driver will only free the mbuf if it is no longer in use. It is the"]
    #[doc = " application\'s responsibity to ensure rte_eth_tx_buffer_flush(..) is"]
    #[doc = " called if needed."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param free_cnt"]
    #[doc = "   Maximum number of packets to free. Use 0 to indicate all possible packets"]
    #[doc = "   should be freed. Note that a packet may be using multiple mbufs."]
    #[doc = " @return"]
    #[doc = "   Failure: < 0"]
    #[doc = "     -ENODEV: Invalid interface"]
    #[doc = "     -EIO: device is removed"]
    #[doc = "     -ENOTSUP: Driver does not support function"]
    #[doc = "   Success: >= 0"]
    #[doc = "     0-n: Number of packets freed. More packets may still remain in ring that"]
    #[doc = "     are in use."]
    pub fn rte_eth_tx_done_cleanup(port_id: u16, queue_id: u16, free_cnt: u32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device {
    pub _address: u8,
}
#[doc = "< mempool used by that queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool {
    pub _address: u8,
}

/******* end of generated code ******/

use std::ptr;

impl rte_eth_dev_info {
    pub fn new_null() -> rte_eth_dev_info {
        rte_eth_dev_info {
            device: ptr::null_mut(),
            driver_name: ptr::null(),
            if_index: 0,
            dev_flags: ptr::null(),
            min_rx_bufsize: 0,
            max_rx_pktlen: 0,
            max_rx_queues: 0,
            max_tx_queues: 0,
            max_mac_addrs: 0,
            max_hash_mac_addrs: 0,
            max_vfs: 0,
            max_vmdq_pools: 0,
            rx_offload_capa: 0,
            tx_offload_capa: 0,
            rx_queue_offload_capa: 0,
            tx_queue_offload_capa: 0,
            reta_size: 0,
            hash_key_size: 0,
            flow_type_rss_offloads: 0,
            default_rxconf: rte_eth_rxconf::new_null(),
            default_txconf: rte_eth_txconf::new_null(),
            vmdq_queue_base: 0,
            vmdq_queue_num: 0,
            vmdq_pool_base: 0,
            rx_desc_lim: rte_eth_desc_lim::new_null(),
            tx_desc_lim: rte_eth_desc_lim::new_null(),
            speed_capa: 0,
            nb_rx_queues: 0,
            nb_tx_queues: 0,
            default_rxportconf: rte_eth_dev_portconf::new_null(),
            default_txportconf: rte_eth_dev_portconf::new_null(),
            dev_capa: 0,
            switch_info: rte_eth_switch_info::new_null(),
        }
    }
}

impl rte_eth_rxconf {
    pub fn new_null() -> rte_eth_rxconf {
        rte_eth_rxconf {
            rx_thresh: rte_eth_thresh::new_null(),
            rx_free_thresh: 0,
            rx_drop_en: 0,
            rx_deferred_start: 0,
            offloads: 0,
        }
    }
}

impl rte_eth_txconf {
    pub fn new_null() -> rte_eth_txconf {
        rte_eth_txconf {
            tx_thresh: rte_eth_thresh::new_null(),
            tx_rs_thresh: 0,
            tx_free_thresh: 0,
            tx_deferred_start: 0,
            offloads: 0,
        }
    }
}

impl rte_eth_thresh {
    pub fn new_null() -> rte_eth_thresh {
        rte_eth_thresh {
            pthresh: 0,
            hthresh: 0,
            wthresh: 0,
        }
    }
}

impl rte_eth_desc_lim {
    pub fn new_null() -> rte_eth_desc_lim {
        rte_eth_desc_lim {
            nb_max: 0,
            nb_min: 0,
            nb_align: 0,
            nb_seg_max: 0,
            nb_mtu_seg_max: 0,
        }
    }
}

impl rte_eth_dev_portconf {
    pub fn new_null() -> rte_eth_dev_portconf {
        rte_eth_dev_portconf {
            burst_size: 0,
            ring_size: 0,
            nb_queues: 0,
        }
    }
}

impl rte_eth_switch_info {
    pub fn new_null() -> rte_eth_switch_info {
        rte_eth_switch_info {
            name: ptr::null(),
            domain_id: 0,
            port_id: 0,
        }
    }
}

const rss_flow_names: [&str; 24] = [
    "Unknown",
    "Raw",
    "Ipv4",
    "FragIpv4",
    "NonFragIpv4Tcp",
    "NonFragIpv4Udp",
    "NonFragIpv4Sctp",
    "NonFragIpv4Other",
    "IPv6",
    "FragIpv6",
    "NonFragIpv6Tcp",
    "NonFragIpv6Udp",
    "NonFragIpv6Sctp",
    "NonFragIpv6Other",
    "L2Payload",
    "Ipv6Ex",
    "Ipv6TcpEx",
    "Ipv6UdpEx",
    "Port",
    "Vxlan",
    "Geneve",
    "Nvgre",
    "VxlanGpe",
    "Max",
];

pub fn rss_flow_name(rss_flow_id: usize) -> &'static str {
    if rss_flow_id <= RTE_ETH_FLOW_MAX as usize {
        rss_flow_names[rss_flow_id]
    } else {
        rss_flow_names[0]
    }
}
